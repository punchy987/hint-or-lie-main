NOTE : Ceci est la base logique de 'Hint or Lie'. Le design HTML/CSS sera refait √† z√©ro.

--- INVENTAIRE DES IMAGES ---
public/images/background-hero.svg

--- FICHIER : package.json ---
{
  "name": "hint-or-lie",
  "version": "1.0.0",
  "description": "Jeu multijoueur en ligne - Hint or Lie (by Mits)",
  "main": "server.js",
  "author": "Mits",
  "license": "ISC",
  "dependencies": {
    "express": "^5.1.0",
    "firebase-admin": "^13.4.0",
    "socket.io": "^4.8.1"
  },
  "scripts": {
    "start": "node server.js",
    "pack": "node pack.js",
    "dev": "nodemon server.js"
  }
}

--- FICHIER : pack.js ---
const fs = require('fs');
const path = require('path');

const dirsToScan = ['public', 'routes', 'config', 'utils'];
let output = "STRUCTURE DU PROJET HINT OR LIE\n\n";
let fileCount = 0;

function scan(dir) {
    if (!fs.existsSync(dir)) return;
    const files = fs.readdirSync(dir);
    files.forEach(file => {
        const fullPath = path.join(dir, file);
        if (fs.statSync(fullPath).isDirectory()) {
            if (file !== 'node_modules' && file !== '.git') scan(fullPath);
        } else {
            console.log(`üìñ Lecture de : ${fullPath}`); // √áa va s'afficher dans ton terminal
            const content = fs.readFileSync(fullPath, 'utf8');
            output += `--- FICHIER : ${fullPath} ---\n${content}\n\n`;
            fileCount++;
        }
    });
}

console.log("üöÄ Lancement du scan des fichiers...");
dirsToScan.forEach(d => scan(d));

fs.writeFileSync('CONTEXTE_PROJET.txt', output);
console.log(`\n‚úÖ Termin√© ! ${fileCount} fichiers ont √©t√© regroup√©s.`);
console.log("üëâ Regarde maintenant dans ta barre lat√©rale VS Code : CONTEXTE_PROJET.txt est l√† !");

--- FICHIER : server.js ---
const express = require('express');
const http = require('http');
const path = require('path');
const { Server } = require('socket.io');

// routes & sockets
const setupRoutes = require('./routes');
const setupSockets = require('./routes/sockets');

// config g√©n√©rale (tes HINT_SECONDS etc. si besoin)
const config = require('./config');

const app = express();
app.use(express.static(path.join(__dirname, 'public')));
setupRoutes(app);

const server = http.createServer(app);
const io = new Server(server, { cors: { origin: '*' } });

// Firebase (optionnel)
let db = null;
try { ({ db } = require('./config/firebase.js')); } 
catch { console.log('‚ö†Ô∏è Firebase non configur√© ‚Äî tests sans persistence.'); }

// branchement sockets
setupSockets(io, db);

// listen
const PORT = process.env.PORT || 5500;
server.listen(PORT, () => console.log('Hint or Lie ‚Äî port', PORT));

--- FICHIER : config/config.js ---
module.exports = {
  HINT_SECONDS: 60,
  VOTE_SECONDS: 45,
  LOBBY_READY_SECONDS: 10
};

--- FICHIER : config/firebase.js ---
// config/firebase.js
const admin = require('firebase-admin');

let db = null;

try {
  // 1) En prod (Render, etc.) : on lit la cl√© depuis une VARIABLE D‚ÄôENV
  //    -> mets tout le JSON de la cl√© dans FIREBASE_SERVICE_ACCOUNT
  let creds = null;
  if (process.env.FIREBASE_SERVICE_ACCOUNT) {
    creds = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);
    // les sauts de ligne arrivent souvent √©chapp√©s dans les env vars
    if (typeof creds.private_key === 'string') {
      creds.private_key = creds.private_key.replace(/\\n/g, '\n');
    }
  } else {
    // 2) En local : on lit le fichier ignor√© par git
    //    (ne JAMAIS le commiter)
    creds = require('./firebase-service-account.json');
  }

  admin.initializeApp({
    credential: admin.credential.cert(creds),
  });

  db = admin.firestore();
  console.log('‚úÖ Firebase configur√©');
} catch (e) {
  console.log('‚ö†Ô∏è Firebase non configur√© ‚Äî', e.message);
}

module.exports = { db };

--- FICHIER : config/index.js ---
// Constantes configurables (via variables d‚Äôenv.)
module.exports = {
  PORT: Number(process.env.PORT) || 3000,
  HINT_SECONDS: Number(process.env.HINT_SECONDS) || 45,
  VOTE_SECONDS: Number(process.env.VOTE_SECONDS) || 40,
  LOBBY_READY_SECONDS: Number(process.env.LOBBY_READY_SECONDS) || 10,
};

--- FICHIER : public/js/main.js ---
// public/js/main.js
// Boot : initialise toutes les features + timers pilotes par le serveur
(function () {
  const { $, fmt, state, socket, startPhaseAnim } = window.HOL;

  function initTimersFromServer() {
    let lastDeadline = null;
    let localTimerRAF = null;

    socket.on('timer', ({ phase, leftMs, totalMs }) => {
      if (phase !== state.currentPhase) state.currentPhase = phase;

      // Recalibrer le deadline du serveur
      lastDeadline = Date.now() + leftMs;

      startPhaseAnim(phase, totalMs || state.DUR[phase] || 0, leftMs);

      // Filet de securite d ecran : si le serveur dit "voting" et qu on est encore sur l ecran "hint", basculer
      if (phase === 'voting' && document.body.getAttribute('data-screen') === 'screen-hint') {
        window.HOL.show('screen-vote');
      }

      // Arreter l ancienne animation et en demarrer une nouvelle
      if (localTimerRAF) cancelAnimationFrame(localTimerRAF);

      function updateLocalTimer() {
        const now = Date.now();
        const remaining = Math.max(0, lastDeadline - now);

        if (phase === 'hints') {
          const el = $('timer-hints'); if (el) el.textContent = fmt(remaining);
          if (remaining <= 0) { $('btn-send-hint')?.setAttribute('disabled', 'true'); $('hint-input')?.setAttribute('disabled', 'true'); }
        } else if (phase === 'voting') {
          const el = $('timer-vote'); if (el) el.textContent = fmt(remaining);
          if (remaining <= 0) { document.querySelectorAll('#hints .vote-card').forEach(b => b.disabled = true); }
        } else if (phase === 'prestart') {
          const el = $('timer-lobby'); if (el) el.textContent = fmt(remaining);
        } else if (phase === 'reveal') {
          const el = $('timer-reveal'); if (el) el.textContent = fmt(remaining);
        } else if (phase === 'lobby') {
          const el = $('timer-lobby'); if (el) { el.textContent = fmt(remaining); if (remaining <= 0) el.style.display = 'none'; }
        }

        if (remaining > 0) {
          localTimerRAF = requestAnimationFrame(updateLocalTimer);
        } else {
          localTimerRAF = null;
        }
      }

      // Demarrer l animation fluide
      updateLocalTimer();
    });

    socket.on('phaseProgress', ({ phase, submitted, total }) => {
      if (phase === 'hints') {
        const el = $('progress-hints');
        if (el) el.textContent = `${submitted}/${total}`;
      } else if (phase === 'voting') {
        const el = $('progress-vote');
        if (el) el.textContent = `${submitted}/${total}`;
      }
    });

    // NOUVEAU : Spectateur devient actif
    socket.on('roomUpdate', (snap) => {
      state.room = snap;

      // Met √† jour le num√©ro du round
      if ($('round-num')) $('round-num').textContent = snap.round;
      
      // Met √† jour le tableau des scores
      if (window.HOL.updateScoreboard) window.HOL.updateScoreboard(snap.players);

      // G√®re l affichage des √©crans en fonction de la phase de jeu
      switch (snap.state) {
        case 'lobby':
          window.HOL.show('screen-lobby');
          break;
        case 'hints':
          window.HOL.show('screen-hint');
          break;
        case 'voting':
          window.HOL.show('screen-vote');
          break;
        case 'reveal':
          // L √©v√©nement `roundResult` dans `results.js` g√®re l affichage 
          // avec une animation, mais on assure ici la transition au cas o√π.
          if (document.body.getAttribute('data-screen') !== 'screen-result') {
            window.HOL.show('screen-result');
          }
          break;
      }
      
      // Met √† jour la liste des joueurs dans le lobby
      const list = $('players');
      if (list) {
          list.innerHTML = '';
          list.style.display = 'grid';
          list.style.gridTemplateColumns = 'repeat(auto-fill, minmax(100px, 1fr))';
          list.style.gap = '10px';
          snap.players.forEach(p => {
              const card = document.createElement('div');
              card.className = 'player-card'; 
              card.style.cssText = 'background:rgba(255,255,255,0.05);border-radius:10px;padding:10px;text-align:center;display:flex;flex-direction:column;align-items:center;border:1px solid rgba(255,255,0.1);';
              const avatarUrl = `https://api.dicebear.com/7.x/bottts/svg?seed=${encodeURIComponent(p.name || 'default')}&backgroundColor=b6e3f4,c0aede,d1d4f9`;
              card.innerHTML = `
                  <img src="${avatarUrl}" style="width:50px;height:50px;border-radius:50%;margin-bottom:6px;" />
                  <div style="font-weight:bold;font-size:0.9rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:100%;">${p.name}</div>
              `;
              list.appendChild(card);
          });
      }

      // Transition spectateur -> actif
      const meNow = snap.players?.find(p => p.id === state.me.id);
      const meBefore = state.room?.players?.find(p => p.id === state.me.id);
      if (meBefore?.spectator && meNow && !meNow.spectator && snap.state === 'lobby') {
        window.HOL.toast('Vous rejoignez la partie !', 1500);
      }
      
      // Ferme les modales si on retourne au lobby
      if (snap.state === 'lobby') {
        const modal = $('modal');
        if (modal && modal.style.display === 'flex') {
          const box = modal.querySelector('.box');
          // Ferme la modale de fin de partie
          if (box && box.innerHTML.includes('PARTIE TERMINEE')) {
            modal.style.display = 'none';
          }
          // Ferme la modale "Partie en cours" pour les spectateurs
          if (box && box.textContent.includes('Partie en cours')) {
            modal.style.display = 'none';
          }
        }
        // R√©active le bouton "Pr√™t" 
        const btnReady = $('btn-ready');
        if (btnReady) {
          btnReady.textContent = 'Je suis pret';
          btnReady.disabled = false;
        }
      }
    });

    // NOUVEAU : Scores reinitialises (apres resetScores)
    socket.on('scoresReset', () => {
      window.HOL.show('screen-lobby');
      const btnReady = $('btn-ready');
      if (btnReady) {
        btnReady.textContent = 'Je suis pret';
        btnReady.disabled = false;
      }
      state.myLobbyReady = false;
      window.HOL.toast('Partie reinitalisee !', 1500);
    });
  }

  function init() {
    window.HOL.features.home.init();
    window.HOL.features.hints.init();
    window.HOL.features.vote.init();
    window.HOL.features.results.init();
    window.HOL.features.leaderboard.init();
    initTimersFromServer();
    // Ecran initial
    document.body.setAttribute('data-screen', 'screen-home');
  }

  if (document.readyState !== 'loading') init();
  else document.addEventListener('DOMContentLoaded', init);
})();

--- FICHIER : public/js/core/dom.js ---
// public/js/core/dom.js
// Helpers DOM globaux + mirroring dans window.HOL
(function () {
  // Accepte: "#id" / ".class" / "div > span"  OU  "id" nu sans '#'
  const pick = (s, root = document) => {
    if (!s) return null;
    const looksLikeSelector = s.startsWith('#') || s.startsWith('.') || /[>[\]:\s]/.test(s);
    return looksLikeSelector ? root.querySelector(s) : root.getElementById(s);
  };
  const pickAll = (s, root = document) => {
    if (!s) return [];
    const looksLikeSelector = s.startsWith('#') || s.startsWith('.') || /[>[\]:\s]/.test(s);
    return looksLikeSelector ? Array.from(root.querySelectorAll(s)) : (root.getElementById(s) ? [root.getElementById(s)] : []);
  };
  const on = (el, type, handler, opts) => el && el.addEventListener(type, handler, opts);

  // Expose global
  window.$  = pick;
  window.$$ = pickAll;
  window.on = on;

  // Expose aussi dans window.HOL (ton code fait: const { $, ‚Ä¶ } = window.HOL)
  window.HOL = window.HOL || {};
  window.HOL.$  = window.HOL.$  || pick;
  window.HOL.$$ = window.HOL.$$ || pickAll;
  window.HOL.on = window.HOL.on || on;
})();

--- FICHIER : public/js/core/helpers.js ---
// public/js/core/helpers.js
(function () {
  const HOL = (window.HOL = window.HOL || {});

  HOL.SCORE_SCREENS = new Set(['screen-hint', 'screen-vote', 'screen-result']);

  // S√©lecteurs
  HOL.$ = HOL.$ || ((s, r = document) => {
    if (!s) return null;
    const bySel = s.startsWith('#') || s.startsWith('.') || /[>[\]:\s]/.test(s);
    return bySel ? r.querySelector(s) : r.getElementById(s);
  });

  HOL.el = HOL.el || function el(tag, text = '', attrs = {}) {
    const n = document.createElement(tag);
    if (text != null && text !== '') n.textContent = String(text);
    for (const [k, v] of Object.entries(attrs || {})) n.setAttribute(k, String(v));
    return n;
  };

  HOL.onEnter = HOL.onEnter || function (idOrSel, fn) {
    const input = HOL.$(idOrSel);
    if (!input) return;
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); fn && fn(); }
    });
  };

  HOL.show = HOL.show || function (screenId) {
    const ids = ['screen-home', 'screen-lobby', 'screen-hint', 'screen-vote', 'screen-result'];
    for (const id of ids) {
      const el = document.getElementById(id);
      if (el) el.style.display = (id === screenId) ? '' : 'none';
    }
    document.body.setAttribute('data-screen', screenId);
    // On d√©place le scoreboard si besoin
    const sb = document.getElementById('scoreboard');
    if (sb) {
      if (HOL.SCORE_SCREENS.has(screenId)) {
        sb.style.display = 'block';
        document.getElementById(screenId).appendChild(sb);
      } else {
        sb.style.display = 'none';
      }
    }
  };

  HOL.toast = HOL.toast || function (msg, ms = 2200) {
    let t = document.getElementById('toast');
    if (!t) return console.log("Toast:", msg);
    t.textContent = String(msg || '');
    t.style.display = 'block';
    t.style.opacity = '1';
    clearTimeout(HOL._toastTimer);
    HOL._toastTimer = setTimeout(() => { t.style.display = 'none'; }, ms);
  };

  HOL.getDeviceId = HOL.getDeviceId || function () {
    const K = 'hol_device_id';
    let id = localStorage.getItem(K);
    if (!id) { id = 'd-' + Math.random().toString(36).slice(2, 9); localStorage.setItem(K, id); }
    return id;
  };

  HOL.fmt = HOL.fmt || function fmt(ms) {
    const s = Math.max(0, Math.floor((ms ?? 0) / 1000));
    return `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;
  };

  HOL.shareInviteLink = async function({ code, name }) {
    const url = `${location.origin}${location.pathname}?code=${code}${name ? '&n='+name : ''}`;
    if (navigator.share) { try { await navigator.share({ title: 'Hint or Lie', text: `Code ${code}`, url }); return; } catch {} }
    try { await navigator.clipboard.writeText(url); HOL.toast('Lien copi√© ‚úÖ'); } catch { HOL.toast('Erreur copie'); }
  };

})();

--- FICHIER : public/js/core/socket.js ---
// public/js/core/socket.js
(function () {
  window.HOL = window.HOL || {};
  
  // On ajoute des options pour Render (transports prioritaires)
  const socket = io({
    transports: ['websocket', 'polling'],
    reconnectionAttempts: 5,
    timeout: 10000
  });

  socket.on('connect', () => {
    console.log('[Socket] Connect√© avec ID:', socket.id);
  });

  socket.on('connect_error', (err) => {
    console.error('[Socket] Erreur de connexion:', err.message);
  });

  // ‚úÖ NOUVELLE: Gestion de la modal spectateur
  socket.on('spectatorMode', ({ phase, message }) => {
    const modal = document.getElementById('spectator-waiting');
    const phaseDisplay = document.getElementById('spectator-phase');
    if (modal) {
      const phaseLabel = {
        'hints': 'üìù Phase Indices',
        'voting': 'üó≥Ô∏è Phase Vote',
        'reveal': 'üé≠ R√©v√©lation',
      }[phase] || '‚è≥ ' + phase;
      
      if (phaseDisplay) phaseDisplay.textContent = phaseLabel;
      modal.style.display = 'block';
      
      // Masquer tous les √©crans
      const screenIds = ['screen-home', 'screen-lobby', 'screen-hint', 'screen-vote', 'screen-result'];
      screenIds.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = 'none';
      });
    }
  });

  // ‚úÖ NOUVELLE: Fermer la modal spectateur quand on rejoint le lobby pour la prochaine manche
  socket.on('roomJoined', () => {
    const modal = document.getElementById('spectator-waiting');
    if (modal) modal.style.display = 'none';
  });

  // ‚úÖ NOUVELLE: Quitter la salle depuis la modal spectateur
  const btnLeaveSpectator = document.getElementById('btn-leave-spectator');
  if (btnLeaveSpectator) {
    btnLeaveSpectator.addEventListener('click', () => {
      socket.emit('leaveRoom');
      const modal = document.getElementById('spectator-waiting');
      if (modal) modal.style.display = 'none';
    });
  }

  // ‚úÖ NOUVELLE: ReconnectHandler - envoi de l √©tat du jeu √† la reconnexion
  socket.on('gameStateSync', ({ state, phase, round, players, scores }) => {
    console.log('[Reconnect] √âtat du jeu re√ßu:', { state, phase, round });
    
    // Mettre √† jour state.js
    if (window.HOL.state) {
      window.HOL.state.currentPhase = phase;
      window.HOL.state.room.state = state;
      window.HOL.state.room.round = round;
      if (players) window.HOL.state.room.players = players;
      if (scores) {
        for (const [id, score] of Object.entries(scores)) {
          const p = window.HOL.state.room.players.find(pl => pl.id === id);
          if (p) p.score = score;
        }
      }
    }
  });

  window.HOL.socket = socket;
})();

--- FICHIER : public/js/core/state.js ---
// public/js/core/state.js
// √âtat global + animations de phase
(function () {
  const HOL = window.HOL || (window.HOL = {});

  const state = {
    me: { id: null, code: null },
    room: { players: [], state: 'lobby', round: 0 },
    myIsImpostor: false,
    myLobbyReady: false,
    currentPhase: null,
    roundDomain: null,  // domaine/th√®me de la manche
    DUR: { hints: 45000, voting: 40000, prestart: 4000 }, // valeurs par d√©faut (le serveur pilote le timer)
    phaseAnim: { phase: null, deadline: 0, total: 0, raf: null },
  };

  function tierFromWins(w) {
    if (w >= 120) return 'Diamond';
    if (w >= 60) return 'Platinum';
    if (w >= 25) return 'Gold';
    if (w >= 10) return 'Silver';
    return 'Bronze';
  }

  // ‚úÖ updateScoreboard est fourni par leaderboard.js

  function resetPhaseProgress() {
    document.querySelectorAll('.phase-progress .bar').forEach(el => el.style.width = '0%');
    document.querySelectorAll('.phase-bar').forEach(el => el.style.setProperty('--progress', '0'));
    stopPhaseAnim();
  }

  function phaseScope(phase) {
    if (phase === 'hints') return document.querySelector('#screen-hint .phase-bar');
    if (phase === 'voting') return document.querySelector('#screen-vote .phase-bar');
    if (phase === 'prestart') return document.querySelector('#screen-result .phase-bar');
    if (phase === 'lobby') return document.querySelector('#screen-lobby .phase-bar');
    return null;
  }

  function tickPhase() {
    const el = phaseScope(state.phaseAnim.phase);
    if (!el) return;
    const left = Math.max(0, state.phaseAnim.deadline - Date.now());
    const done = Math.min(1, (state.phaseAnim.total - left) / Math.max(1, state.phaseAnim.total));
    el.style.setProperty('--progress', String(done));
    const bar = el.querySelector('.phase-progress .bar');
    if (bar) bar.style.width = `${Math.round(done * 100)}%`;
    if (left > 0) {
      state.phaseAnim.raf = requestAnimationFrame(tickPhase);
    } else {
      state.phaseAnim.raf = null;
      document.body.classList.add('flash-now');
      setTimeout(() => document.body.classList.remove('flash-now'), 260);
    }
  }

  function stopPhaseAnim() { if (state.phaseAnim.raf) cancelAnimationFrame(state.phaseAnim.raf); state.phaseAnim.raf = null; }

  function startPhaseAnim(phase, totalMs, leftMs) {
    if (!phase || !totalMs) return;
    state.phaseAnim.phase = phase; state.phaseAnim.total = totalMs; state.phaseAnim.deadline = Date.now() + (leftMs ?? totalMs);
    stopPhaseAnim(); state.phaseAnim.raf = requestAnimationFrame(tickPhase);
  }

  // ‚ö†Ô∏è NE PAS r√©√©crire HOL.getDeviceId ici.
  // helpers.js fournit d√©j√† HOL.getDeviceId ; on le laisse tel quel.

  Object.assign(HOL, {
    state,
    tierFromWins,
    resetPhaseProgress,
    startPhaseAnim,
    stopPhaseAnim,
    // üëá On n ajoute PAS getDeviceId ici pour √©viter d √©craser celui de helpers.js
  });
})();

--- FICHIER : public/js/dev/guard.js ---
// public/js/dev/guard.js
(function () {
  // Activer/d√©sactiver le mode debug
  const DEBUG = /[?&](dev|debug)=1/i.test(location.search) || window.HOL_DEBUG === true;

  function log(...a){ console.log('[GUARD]', ...a); }
  function warn(...a){ console.warn('[GUARD]', ...a); }

  function checkDOM() {
    const required = [
      'screen-home','screen-lobby','screen-hint','screen-vote','screen-result',
      'btn-create','btn-join','name-create','name-join','join-code',
      'hint-input','btn-send-hint','hint-status','impostor-tip','hint-instruction',
      'vote-buttons','hints',
      'scoreboard','score-list',
      'lobby-ready-pill','round-num','timer-hints','timer-vote','timer-reveal'
    ];
    const missing = required.filter(id => !document.getElementById(id));
    if (missing.length) warn('IDs manquants dans le DOM:', missing);
  }

  function checkHOL() {
    const ok = (p) => {
      try { return !!eval(p); } catch { return false; }
    };
    const reqFns = [
      'window.HOL', 'HOL.$', 'HOL.onEnter', 'HOL.show', 'HOL.fmt',
      'HOL.updateScoreboard',
      'HOL.features && HOL.features.home && HOL.features.home.init',
      'HOL.features && HOL.features.hints && HOL.features.hints.init',
      'HOL.features && HOL.features.vote && HOL.features.vote.init',
      'HOL.features && HOL.features.results && HOL.features.results.init',
    ];
    const miss = reqFns.filter(p => !ok(p));
    if (miss.length) warn('Fonctions/modules attendus non pr√©sents:', miss);
  }

  function wireSocketLogging() {
    const s = window.HOL && window.HOL.socket;
    if (!s) { warn('Socket HOL manquant'); return; }
    // Forcer l affichage des emits et des √©v√©nements entrants
    const origEmit = s.emit.bind(s);
    s.emit = (ev, ...args) => { console.log('[emit]', ev, ...args); return origEmit(ev, ...args); };
    if (s.onAny) s.onAny((ev, ...args) => console.log('‚üµ', ev, ...args));
    log('Socket logging activ√©');
  }

  function run() {
    checkDOM();
    checkHOL();
    wireSocketLogging();
    if (DEBUG) {
      window.addEventListener('error', (e) => warn('JS error:', e.message, e.filename+':'+e.lineno));
      log('Mode DEBUG actif');
    }
  }

  if (document.readyState !== 'loading') run();
  else document.addEventListener('DOMContentLoaded', run);
})();

--- FICHIER : public/js/features/hints.js ---
(function () {
  const { $, $$, toast, show, state, socket, resetPhaseProgress, onEnter } = window.HOL;

  let sending = false;
  let locked  = false;
  let liveBox = null;
  let liveList = null;

  const ui = {
    role:   () => $('my-role'),
    theme:  () => $('theme-hint-name'),
    tip:    () => $('impostor-tip'),
    input:  () => $('hint-input'),
    send:   () => $('btn-send-hint'),
    status: () => $('hint-status'),
    wordChip:     () => $('crew-word-chip'),
    wordChipText: () => $('crew-word'),
  };

  function applyRoleTheme(isImpostor) {
    const body = document.body;
    body.classList.remove('theme-impostor', 'theme-crew');
    if (isImpostor) {
      body.classList.add('theme-impostor');
      body.style.animation = 'flash-red 0.5s ease-out';
      setTimeout(() => body.style.animation = '', 500);
    } else {
      body.classList.add('theme-crew');
    }
  }

  function resetTheme() {
    document.body.classList.remove('theme-impostor', 'theme-crew');
  }

  function playRoleCinematic(isImpostor, callback) {
    const overlay = $('role-reveal-overlay');
    const roleText = $('reveal-role-text');
    if (!overlay || !roleText) { callback(); return; } 

    overlay.style.display = ''; // Force le nettoyage du style inline pour laisser le CSS agir
    roleText.textContent = isImpostor ? 'IMPOSTEUR' : '√âQUIPIER';
    roleText.className = isImpostor ? 'impostor' : 'crew';
    overlay.classList.add('playing');

    setTimeout(() => {
      overlay.classList.remove('playing');
      callback(); 
    }, 3000); 
  }

  function setRound(num) { $$('.round-live').forEach(el => el.textContent = String(num || 0)); }
  
  function ensureLiveUI() {
    if (liveBox && liveList) return;
    liveBox = document.createElement('div');
    liveBox.id = 'crew-live-box';
    liveBox.className = 'tip';
    liveBox.innerHTML = `<strong>üì° Indices intercept√©s (live)</strong><ul id="crew-live-list" style="margin-top:8px;"></ul>`;
    liveList = liveBox.querySelector('#crew-live-list');
  }

  function sendHint() {
    if (locked || sending) return;
    const val = (ui.input()?.value || '').trim();
    if (!val) {
      const status = ui.status();
      if (status) {
        status.textContent = '√âcris un indice üòâ';
        status.classList.add('error');
        setTimeout(() => {
          if (status.textContent === '√âcris un indice üòâ') {
            status.textContent = '';
            status.classList.remove('error');
          }
        }, 2200);
      }
      return;
    }
    sending = true;
    ui.send().disabled = true;
    socket.emit('submitHint', { hint: val });
  }

  function initSocket() {
    socket.on('roundInfo', ({ word, wordDisplay, isImpostor, domain, round }) => {
      playRoleCinematic(isImpostor, () => {
        state.myIsImpostor = !!isImpostor;
        sending = false; locked = false;
        const status = ui.status();
        if (status) {
          status.textContent = '';
          status.classList.remove('error');
        }
        show('screen-hint');
        resetPhaseProgress();
        applyRoleTheme(isImpostor);

        if (ui.theme()) ui.theme().textContent = domain || '‚Äî';
        if (ui.role()) {
          ui.role().textContent = isImpostor ? 'IMPOSTEUR' : '√âQUIPIER';
          ui.role().style.color = isImpostor ? 'var(--danger)' : 'var(--crew)';
        }

        const tipEl = ui.tip();
        if (isImpostor) {
          tipEl.style.display = 'block';
          tipEl.innerHTML = "ü§´ <strong>CHUT !</strong> Tu n‚Äôas pas de mot.<br>Observe les indices et invente un mensonge !";
          ui.wordChip().style.display = 'none';
          ensureLiveUI();
          if (liveList) liveList.innerHTML = ''; // Nettoie les anciens indices
          ui.input()?.insertAdjacentElement('beforebegin', liveBox);
          liveBox.style.display = 'block';
        } else {
          tipEl.style.display = 'none';
          ui.wordChip().style.display = 'block';
          ui.wordChipText().textContent = wordDisplay || word || '‚Äî';
          if (liveBox) liveBox.style.display = 'none';
        }

        ui.input().value = '';
        ui.input().disabled = false;
        ui.send().disabled = false;
        setRound(round);
      });
    });

    socket.on('hintAck', () => {
      locked = true; sending = false;
      const status = ui.status();
      if (status) {
        status.textContent = 'Indice envoy√© ‚úÖ';
        status.classList.remove('error');
      }
    });

    socket.on('hintRejected', ({ reason }) => {
      sending = false;
      const btn = ui.send();
      if (btn) btn.disabled = false;
      const status = ui.status();
      if (status) {
        status.textContent = reason || 'Indice rejet√©.';
        status.classList.add('error');
      }
      toast(reason || 'Indice rejet√©.', 'danger');
    });

    socket.on('crewHintsLive', ({ hints }) => {
      if (!state.myIsImpostor) return;
      ensureLiveUI();
      liveList.innerHTML = '';
      hints.forEach(h => {
        const li = document.createElement('li');
        li.className = 'live-hint-item';

        const nameSpan = document.createElement('span');
        nameSpan.className = 'live-hint-name';
        nameSpan.textContent = h.name;

        const hintSpan = document.createElement('span');
        hintSpan.className = 'live-hint-text';
        hintSpan.textContent = `"${h.hint}"`;

        li.appendChild(nameSpan);
        li.appendChild(hintSpan);

        liveList.appendChild(li);
      });
    });

    socket.on('crewHintAdded', (h) => {
      if (!state.myIsImpostor) return;
      ensureLiveUI();
      const li = document.createElement('li');
      li.className = 'live-hint-item';

      const nameSpan = document.createElement('span');
      nameSpan.className = 'live-hint-name';
      nameSpan.textContent = h.name;

      const hintSpan = document.createElement('span');
      hintSpan.className = 'live-hint-text';
      hintSpan.textContent = `"${h.hint}"`;

      li.appendChild(nameSpan);
      li.appendChild(hintSpan);
      
      const delay = liveList.children.length * 100;
      li.style.animationDelay = `${delay}ms`;

      liveList.appendChild(li);
    });

    socket.on('timer', ({ phase, leftMs }) => {
      if (phase !== 'hints' && phase !== 'prestart') resetTheme();
    });
  }

  function init() { 
    ui.send()?.addEventListener('click', sendHint);
    onEnter('hint-input', sendHint);
    initSocket(); 
  }

  window.HOL.features = window.HOL.features || {};
  window.HOL.features.hints = { init };
})();

--- FICHIER : public/js/features/home.js ---
(function () {
    const { $, el, onEnter, show, toast, getDeviceId, state, updateScoreboard, socket } = window.HOL;

    function updateAvatarPreview(name) {
        const seed = (name || '').trim() || 'Joueur';
        const url = `https://api.dicebear.com/7.x/bottts/svg?seed=${encodeURIComponent(seed)}&backgroundColor=b6e3f4,c0aede,d1d4f9`;
        // Mettre √† jour les deux images
        const imgs = document.querySelectorAll('[id^="avatar-preview-img"]');
        imgs.forEach(img => {
            img.src = url;
        });
    }

    function initTabs() {
        const tabs = { join: $('tab-join'), create: $('tab-create') };
        const panes = { join: $('pane-join'), create: $('pane-create') };

        function activateTab(which) {
            const isJoin = which === 'join';
            tabs.join?.setAttribute('aria-selected', isJoin ? 'true' : 'false');
            tabs.create?.setAttribute('aria-selected', isJoin ? 'false' : 'true');
            panes.join?.classList.toggle('active', isJoin);
            panes.create?.classList.toggle('active', !isJoin);
            
            const input = isJoin ? $('name-join') : $('name-create');
            input?.focus();
            updateAvatarPreview(input?.value);
        }

        tabs.join?.addEventListener('click', () => activateTab('join'));
        tabs.create?.addEventListener('click', () => activateTab('create'));
        $('join-code')?.addEventListener('input', e => { e.target.value = e.target.value.replace(/\D/g, '').slice(0, 4); });

        ['name-join', 'name-create'].forEach(id => {
            const input = $(id);
            if (input) {
                input.addEventListener('input', (e) => updateAvatarPreview(e.target.value));
            }
        });
    }

    function initHomeActions() {

        $('btn-join').onclick = () => {
            const name = $('name-join')?.value.trim() || 'Joueur';
            const code = ($('join-code')?.value.trim() || '').replace(/\D/g, '').slice(0, 4);
            if (code.length !== 4) { toast('Code √† 4 chiffres requis.'); return; }
            socket.emit('hello', { deviceId: getDeviceId(), pseudo: name, name });
            socket.emit('joinRoom', { code, pseudo: name, name, deviceId: getDeviceId() });
        };

        $('btn-create').onclick = () => {
            const name = $('name-create')?.value.trim() || 'Joueur';
            console.log('[Home] Cr√©ation de salle avec le pseudo:', name);
            socket.emit('hello', { deviceId: getDeviceId(), pseudo: name });
            socket.emit('createRoom', { name: name, deviceId: getDeviceId() });
        };

        // GESTION DES REGLES AVEC GAME JUICE
        $('btn-how')?.addEventListener('click', () => {
            const panel = $('how');
            const btn = $('btn-how');
            const visible = panel.style.display !== 'none';

            // Effet de jus : rebond au clic
            btn.style.transform = "scale(0.92)";
            setTimeout(() => btn.style.transform = "scale(1)", 100);

            if (visible) {
                panel.style.display = 'none';
                btn.textContent = 'R√®gles rapides';
            } else {
                panel.style.display = 'block';
                btn.textContent = 'Masquer les r√®gles';
                // Scroll fluide pour mobile
                panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        });

        $('btn-ready')?.addEventListener('click', () => {
            const roomState = window.HOL?.state?.room?.state;
            const br = $('btn-ready');

            // Cas 1 : Phase reveal (apr√®s une manche)
            if (roomState === 'reveal') {
                socket.emit('playerReadyNext');
                if (br) {
                    br.textContent = 'Pr√™t ‚úì';
                    br.disabled = true;
                }
                return;
            }

            // Cas 2 : Phase lobby (avant manche ou apr√®s gameOver)
            if (roomState === 'lobby') {
                state.myLobbyReady = !state.myLobbyReady;
                
                if (br) {
                    br.textContent = state.myLobbyReady ? 'Annuler pr√™t' : 'Je suis pr√™t';
                    br.style.opacity = state.myLobbyReady ? '1' : '0.8';
                }
                
                socket.emit('playerReadyLobby', { ready: state.myLobbyReady });
                return;
            }

            // Cas 3 : En manche (hints/voting) ‚Üí d√©sactiv√©
            if (br) {
                br.disabled = true;
                br.title = 'Manche en cours...';
            }
        });

        $('btn-back-home')?.addEventListener('click', () => {
            socket.emit('leaveRoom');
            state.myLobbyReady = false;
            if ($('btn-ready')) $('btn-ready').textContent = 'Je suis pr√™t';
            show('screen-home');
        });

        onEnter('name-join', () => $('btn-join')?.click());
        onEnter('join-code', () => $('btn-join')?.click());
        onEnter('name-create', () => $('btn-create')?.click());
    }

    function initSocketRoom() {
        socket.on('system', ({ text }) => toast(text));
        socket.on('host-changed', ({ hostId }) => {
            const hb = $('host-badge');
            if (hb) hb.style.display = (window.HOL.state.me.id === hostId) ? 'inline-block' : 'none';
        });
        
        socket.on('connect', () => {
            socket.emit('getLeaderboard');
            state.me.id = socket.id;
        });

        const codeSpan = $('lobby-code');
        if (codeSpan && !codeSpan._wired) {
            codeSpan._wired = true;
            const pill = codeSpan.parentElement;
            if (pill) {
                pill.style.cursor = 'pointer';
                pill.addEventListener('click', async () => {
                    try { await navigator.clipboard.writeText(codeSpan.textContent.trim()); toast('Code copi√© üìã'); } 
                    catch { toast('Copie impossible'); }
                });
            }
        }

        const onRoomEntry = ({ code }) => {
            state.me.code = code;
            $('lobby-code').textContent = code;
            show('screen-lobby');
            state.myLobbyReady = false;
            if ($('btn-ready')) $('btn-ready').textContent = 'Je suis pr√™t';
        };

        socket.on('roomCreated', onRoomEntry);
        socket.on('roomJoined', onRoomEntry);
        socket.on('roomError', ({ message }) => toast(message || 'Erreur de salle.'));




        socket.on('lobbyReadyProgress', ({ ready, total }) => {
            if ($('lobby-ready-pill')) $('lobby-ready-pill').textContent = `${ready}/${total} pr√™ts`;
        });

        socket.on('lobbyCountdownStarted', ({ seconds }) => {
            const el = $('timer-lobby');
            if (el) { el.style.display = 'inline-block'; el.textContent = `00:${String(seconds).padStart(2, '0')}`; }
        });

        socket.on('spectatorMode', ({ message }) => {
            // ‚úÖ Ne montrer la modal que si on n est pas au lobby
            if (state.room?.state === 'lobby') return;
            
            const modal = document.getElementById('modal');
            if (!modal) return;
            
            const box = modal.querySelector('.box');
            if(box) {
                box.innerHTML = `
                    <h2>‚è≥ Partie en cours</h2>
                    <p>${message || 'Veuillez patienter, vous rejoindrez la prochaine manche.'}</p>
                    <p style="margin-top:15px; font-size:0.8rem; opacity:0.7;">Vous pouvez suivre le d√©roulement en attendant.</p>
                `;
            }
            
            modal.style.display = 'flex';
            // ‚úÖ Message persiste jusqu √† la fin de la manche (pas de fermeture automatique)
        });

        // ‚úÖ NOUVEAU : R√©initialiser les boutons √† la sortie
        socket.on('leftRoom', () => {
            state.myLobbyReady = false;
            const btnReady = $('btn-ready');
            if (btnReady) {
                btnReady.textContent = 'Je suis pr√™t';
                btnReady.disabled = false;
                btnReady.style.opacity = '0.8';
                btnReady.title = '';
            }
            window.HOL.show('screen-home');
        });
    }

    function init() {
        initTabs();
        initHomeActions();
        initSocketRoom();
    }

    window.HOL.features = window.HOL.features || {};
    window.HOL.features.home = { init };
})();

--- FICHIER : public/js/features/leaderboard.js ---
// public/js/features/leaderboard.js
// ‚úÖ Scoreboard unifi√© avec structure grid : LED | AVATAR | NOM | PTS

(function () {
  const { $ } = window.HOL;

  function updateScoreboard(players) {
    const list = $('score-list');
    if (!list) return;

    list.innerHTML = '';
    const sorted = [...(players || [])].sort((a, b) => (b.score || 0) - (a.score || 0));

    sorted.forEach(p => {
      const li = document.createElement('li');
      
      // ‚úÖ 1. LED (positionn√© en absolute, parent en relative)
      const ledContainer = document.createElement('div');
      ledContainer.style.cssText = 'position: relative; width: 10px; height: 32px;';
      
      const led = document.createElement('div');
      led.className = 'status-led';
      
      // Logique de couleur
      if (p.disconnected) {
        led.classList.add('is-disconnected');
      } else if (p.spectator) {
        led.classList.add('is-ready');  // Orange pour spectateur
      } else if (p.active) {
        led.classList.add('is-active');  // Vert pour actif
      }
      
      ledContainer.appendChild(led);
      li.appendChild(ledContainer);

      // ‚úÖ 2. Avatar (taille forc√©e)
      const img = document.createElement('img');
      const seed = (p.name || '').trim() || 'default';
      img.src = `https://api.dicebear.com/7.x/bottts/svg?seed=${encodeURIComponent(seed)}&backgroundColor=b6e3f4,c0aede,d1d4f9`;
      img.className = 'score-avatar';
      img.style.cssText = 'width: 32px; height: 32px; border-radius: 50%; object-fit: cover; background: rgba(255, 255, 255, 0.05);';
      li.appendChild(img);

      // ‚úÖ 3. Nom (avec mention si spectateur)
      let nameText = p.name || 'Joueur';
      if (p.spectator) nameText += ' (en attente)';
      if (p.disconnected) nameText += ' (d√©connect√©)';
      
      const nameSpan = document.createElement('span');
      nameSpan.className = 'name';
      nameSpan.textContent = nameText;
      li.appendChild(nameSpan);

      // ‚úÖ 4. Score
      const scoreSpan = document.createElement('span');
      scoreSpan.className = 'pts';
      scoreSpan.textContent = String(p.score || 0);
      li.appendChild(scoreSpan);

      // Highlight du joueur local
      if (p.id === window.HOL?.state?.me?.id) {
        li.classList.add('me');
      }

      list.appendChild(li);
    });
  }

  function init() {}

  window.HOL = window.HOL || {};
  window.HOL.updateScoreboard = updateScoreboard;
  window.HOL.features = window.HOL.features || {};
  window.HOL.features.leaderboard = { init };
})();

--- FICHIER : public/js/features/results.js ---
(function () {
  const { $, show, socket, state } = window.HOL;

  function initUI() {
    $('btn-next').onclick = () => {
      $('btn-next').disabled = true;
      $('btn-next').textContent = 'Pr√™t ‚úì';
      socket.emit('playerReadyNext');
    };
    $('btn-modal-lobby').onclick = () => { 
      show('screen-lobby'); 
      $('modal').style.display = 'none'; 
    };
  }

  function initSocket() {
    // ========== MANCHE NORMALE ========== 
    socket.on('roundResult', (res) => {
      if (res.isGameOver) return; // D√©l√©gu√©e √† gameOver

      const resultOverlay = $('result-reveal-overlay');
      const resultText = $('reveal-result-text');
      const win = state.myIsImpostor ? !res.impostorCaught : res.impostorCaught;

      // Cin√©matique victoire/d√©faite
      resultText.textContent = win ? 'VICTOIRE !' : 'D√âFAITE...';
      resultText.className = win ? 'victory' : 'defeat';
      resultOverlay.classList.add('playing');

      // Confetti si victoire
      if (win && window.confetti) {
        confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } });
      }

      setTimeout(() => {
        resultOverlay.classList.remove('playing');
        show('screen-result');

        $('btn-next').disabled = false;
        $('btn-next').textContent = 'Manche suivante';
        $('res-common').textContent = res.common || '';

        const impName = res.impostorName || '(?)';
        const impContainer = $('res-imp-name');
        impContainer.innerHTML = '';
        impContainer.style.display = 'flex';
        impContainer.style.flexDirection = 'column';
        impContainer.style.alignItems = 'center';
        impContainer.style.gap = '10px';

        const img = document.createElement('img');
        img.src = `https://api.dicebear.com/7.x/bottts/svg?seed=${encodeURIComponent(impName)}&backgroundColor=b6e3f4,c0aede,d1d4f9`;
        img.style.width = '120px';
        img.style.height = '120px';
        img.style.borderRadius = '50%';
        img.style.border = `4px solid ${res.impostorCaught ? 'var(--crew)' : 'var(--danger)'}`;
        img.style.boxShadow = `0 0 20px rgba(${res.impostorCaught ? '59, 130, 246' : '239, 68, 68'}, 0.4)`;

        const nameSpan = document.createElement('span');
        nameSpan.textContent = impName;
        nameSpan.style.fontSize = '1.8rem';
        nameSpan.style.fontWeight = '900';
        nameSpan.style.color = res.impostorCaught ? 'var(--crew)' : 'var(--danger)';

        impContainer.appendChild(img);
        impContainer.appendChild(nameSpan);

        // D√©tail des votes (staggered)
        const votesContainer = $('res-votes');
        votesContainer.innerHTML = '';

        if (res.votesDetail && state.room?.players) {
          const title = document.createElement('h4');
          title.textContent = 'D√©tail des votes';
          title.style.textAlign = 'center';
          title.style.marginBottom = '10px';
          votesContainer.appendChild(title);

          const votesList = document.createElement('div');
          votesList.style.display = 'flex';
          votesList.style.flexDirection = 'column';
          votesList.style.gap = '8px';
          votesList.style.alignItems = 'center';

          const playersById = new Map(state.room.players.map(p => [p.id, p.name]));
          const voteEntries = Object.entries(res.votesDetail);

          voteEntries.forEach(([voterId, votedId], index) => {
            setTimeout(() => {
              const voterName = playersById.get(voterId);
              const votedName = playersById.get(votedId);

              if (voterName && votedName) {
                const voteElement = document.createElement('div');
                voteElement.style.display = 'flex';
                voteElement.style.alignItems = 'center';
                voteElement.style.gap = '8px';
                voteElement.style.padding = '4px 8px';
                voteElement.style.background = 'rgba(255, 255, 255, 0.05)';
                voteElement.style.borderRadius = '6px';
                voteElement.style.width = 'fit-content';

                const voterSpan = document.createElement('span');
                voterSpan.textContent = voterName;
                voterSpan.style.fontWeight = '700';

                const arrow = document.createElement('span');
                arrow.textContent = '‚Üí';
                arrow.style.color = 'var(--muted)';

                const votedSpan = document.createElement('span');
                votedSpan.textContent = votedName;
                votedSpan.style.fontWeight = '700';
                votedSpan.style.color = votedId === res.impostorId ? 'var(--danger)' : 'var(--crew)';

                voteElement.appendChild(voterSpan);
                voteElement.appendChild(arrow);
                voteElement.appendChild(votedSpan);
                votesList.appendChild(voteElement);
              }
            }, index * 400);
          });

          votesContainer.appendChild(votesList);
        }
      }, 2500);
    });

    // ========== FIN DE PARTIE (10 PTS) ========== 
    socket.on('gameOver', ({ winners, finalScores, winnersCount }) => {
      // ‚úÖ Cin√©matique finale spectaculaire
      const resultOverlay = $('result-reveal-overlay');
      const resultText = $('reveal-result-text');

      const playerWon = winners.some(w => w.id === state.me.id);

      resultText.textContent = winnersCount > 1 ? 'üèÜ √âGALIT√â !' : 'üèÜ PARTIE TERMIN√âE !';
      resultText.style.fontSize = 'clamp(2rem, 10vw, 5rem)';
      resultText.className = playerWon ? 'victory' : 'defeat';
      resultOverlay.classList.add('playing');

      // Confetti spectaculaire
      if (playerWon && window.confetti) {
        confetti({ particleCount: 200, spread: 90, origin: { y: 0.6 }, gravity: 0.8 });
        setTimeout(() => {
          confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 } });
        }, 500);
      }

      setTimeout(() => {
        resultOverlay.classList.remove('playing');
        showGameOverModal(winners, finalScores);
      }, 3500);
    });


  }

  function showGameOverModal(winners, finalScores) {
    const modal = $('modal');
    if (!modal) return;

    modal.style.display = 'flex';
    const box = modal.querySelector('.box');
    if (!box) return;

    // Titre
    const title = document.createElement('h2');
    title.style.cssText = `
      font-size: 2.5rem;
      text-align: center;
      background: linear-gradient(45deg, var(--accent), #ff3b3b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 20px;
      animation: pulse-glow 1.5s ease-in-out infinite;
    `;
    title.textContent = 'üèÜ PARTIE TERMIN√âE !';

    // Gagnant(s)
    const winnersSection = document.createElement('div');
    winnersSection.style.cssText = `
      background: rgba(74, 222, 128, 0.1);
      border: 2px solid rgba(74, 222, 128, 0.3);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
      text-align: center;
    `;

    const winnersTitle = document.createElement('h3');
    winnersTitle.textContent = winners.length > 1 ? 'Gagnants üéâ' : 'Gagnant üéâ';
    winnersTitle.style.cssText = 'margin-top: 0; color: var(--accent-3);';
    winnersSection.appendChild(winnersTitle);

    winners.forEach((w, i) => {
      const winnerDiv = document.createElement('div');
      winnerDiv.style.cssText = `
        padding: 8px;
        margin: 8px 0;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        font-weight: 800;
        font-size: 1.3rem;
        animation: slideInRight ${0.5 + i * 0.2}s ease-out;
      `;
      winnerDiv.innerHTML = `
        <img src="https://api.dicebear.com/7.x/bottts/svg?seed=${encodeURIComponent(w.name)}" 
             style="width: 48px; height: 48px; border-radius: 50%; margin-right: 12px; vertical-align: middle;">
        <span>${w.name}</span>
        <span style="color: var(--accent-3); margin-left: 12px;">+${w.score}pts</span>
      `;
      winnersSection.appendChild(winnerDiv);
    });

    // Scoreboard final
    const scoreboardSection = document.createElement('div');
    scoreboardSection.style.cssText = `
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
    `;

    const scoreboardTitle = document.createElement('h4');
    scoreboardTitle.textContent = 'Classement Final';
    scoreboardTitle.style.cssText = 'text-align: center; margin-top: 0; color: var(--muted);';
    scoreboardSection.appendChild(scoreboardTitle);

    if (state.room?.players) {
      const sorted = [...state.room.players]
        .sort((a, b) => (finalScores[b.id] || 0) - (finalScores[a.id] || 0));

      sorted.forEach((p, i) => {
        const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '¬∑';
        const scoreDiv = document.createElement('div');
        scoreDiv.style.cssText = `
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 8px;
          border-bottom: 1px solid rgba(255, 255, 255, 0.05);
          animation: fadeIn ${0.3 + i * 0.1}s ease-out;
        `;
        scoreDiv.innerHTML = `
          <span>${medal} ${p.name}</span>
          <span style="font-weight: 800; color: var(--accent);">${finalScores[p.id] || 0}pts</span>
        `;
        scoreboardSection.appendChild(scoreDiv);
      });
    }

    // Boutons action
    const actionsDiv = document.createElement('div');
    actionsDiv.style.cssText = `
      display: flex;
      gap: 10px;
      margin-top: 20px;
    `;

    const btnHome = document.createElement('button');
    btnHome.textContent = 'üè† Accueil';
    btnHome.type = 'button';
    btnHome.style.cssText = `
      flex: 1;
      padding: 12px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 8px;
      font-weight: 800;
      cursor: pointer;
      transition: 0.2s;
    `;
    btnHome.onclick = () => {
      modal.style.display = 'none';
      socket.emit('leaveRoom');
      // ‚úÖ Attendre le signal leftRoom pour changer d'√©cran
    };
    btnHome.onmouseover = () => btnHome.style.opacity = '0.9';
    btnHome.onmouseout = () => btnHome.style.opacity = '1';

    const btnRestart = document.createElement('button');
    btnRestart.textContent = 'üîÑ Recommencer';
    btnRestart.type = 'button';

    const isHost = window.HOL?.state?.room?.hostId === window.HOL?.state?.me?.id;

    if (isHost) {
      // ‚úÖ H√¥te peut recommencer
      btnRestart.style.cssText = `
        flex: 1;
        padding: 12px;
        background: var(--accent);
        color: #4d0d17;
        border: none;
        border-radius: 8px;
        font-weight: 800;
        cursor: pointer;
        transition: 0.2s;
      `;
      btnRestart.onclick = () => {
        modal.style.display = 'none';
        socket.emit('resetScores');
        // ‚úÖ Attendre le signal scoresReset pour transition
      };
      btnRestart.onmouseover = () => btnRestart.style.opacity = '0.9';
      btnRestart.onmouseout = () => btnRestart.style.opacity = '1';
    } else {
      // ‚úÖ Non-h√¥te : d√©sactiv√©
      btnRestart.textContent = 'üîÑ Seul l h√¥te peut recommencer';
      btnRestart.disabled = true;
      btnRestart.style.cssText = `
        flex: 1;
        padding: 12px;
        background: rgba(255, 255, 255, 0.1);
        color: var(--muted);
        border: none;
        border-radius: 8px;
        font-weight: 800;
        cursor: not-allowed;
      `;
    }

    actionsDiv.appendChild(btnHome);
    actionsDiv.appendChild(btnRestart);

    // Assemble la modale
    box.innerHTML = '';
    box.appendChild(title);
    box.appendChild(winnersSection);
    box.appendChild(scoreboardSection);
    box.appendChild(actionsDiv);
  }

  function init() { initUI(); initSocket(); }
  window.HOL.features = window.HOL.features || {};
  window.HOL.features.results = { init };
})();

--- FICHIER : public/js/features/vote.js ---
// public/js/features/vote.js
// Phase "Vote" ‚Äî Affichage en mode "Cartes / Tuiles" üÉè

(function () {
  const { $, show, socket, resetPhaseProgress, state } = window.HOL;

  let myTarget = null;     // dernier choix local (hintId)
  let votingClosed = false;

  // Fixe le th√®me avec fallback
  function setVoteTheme(domainMaybe) {
    const text = 
      (domainMaybe && String(domainMaybe).trim()) || 
      (state?.roundDomain && String(state.roundDomain).trim()) || 
      ($('theme-hint-name')?.textContent?.trim()) || 
      '‚Äî';
    const el = $('theme-vote-name');
    if (el) el.textContent = text;
  }

  // --- NOUVEAU RENDU : CARTES CLIQUABLES ---
  function renderHintsWithVote(hints) {
    const box = $('hints'); if (!box) return;
    
    // Nettoyage ancien syst√®me (si encore pr√©sent)
    // Le conteneur #hints contient maintenant directement les cartes

    box.style.display = '';   
    box.innerHTML = ''; // On efface la liste pr√©c√©dente

    const shuffledHints = [...(hints || [])].sort(() => Math.random() - 0.5);

    shuffledHints.forEach(h => {
      // Cr√©ation de la CARTE (c est un bouton g√©ant)
      const card = document.createElement('button');
      card.type = 'button';
      card.className = 'vote-card'; // La classe CSS qu on a ajout√©e tout √† l heure
      card.dataset.id = h.id;

      // Le texte de l indice
      const fullText = (h.text ?? h.hint ?? '').toString().trim();
      const strong = document.createElement('strong');
      strong.textContent = fullText || '‚Äî';
      
      card.appendChild(strong);

      // Le clic sur la carte
      card.onclick = () => {
        if (votingClosed) return;
        myTarget = h.id;

        // Visuel : On retire la s√©lection des autres cartes et on allume celle-ci
        box.querySelectorAll('.vote-card').forEach(b => b.classList.remove('selected'));
        card.classList.add('selected');

        // Envoi au serveur
        socket.emit('submitVote', { hintId: h.id });

        // Petit effet imm√©diat sur le compteur (UX fluide)
        const pv = $('progress-vote');
        if (pv) {
          const [cur, tot] = (pv.textContent || '0/0').split('/').map(x => parseInt(x, 10) || 0);
          if (cur < tot) pv.textContent = `${cur + 1}/${tot}`;
        }
      };

      box.appendChild(card);
    });
  }
  // ------------------------------------------

  // Handler commun pour recevoir la liste des indices
  function handleHintsForVote(hints, domain, round) {
    votingClosed = false;
    myTarget = null;

    show('screen-vote');
    resetPhaseProgress();

    setVoteTheme(domain);           
    renderHintsWithVote(hints);     // Affiche les cartes

    const pv = $('progress-vote'); if (pv) pv.textContent = `0/${(hints || []).length}`;
  }

  function initSocket() {
    // Format nouveau: { hints:[{id,text}], domain, round }
    socket.on('hintsList', (payload) => {
      const raw = Array.isArray(payload) ? payload : (payload?.hints || []);
      const hints = raw.map(h => ({
        id: h.id,
        // supporte h.text (nouveau) et h.hint (ancien)
        text: (typeof h.text === 'string') ? h.text : (h.hint || '')
      }));
      const domain = Array.isArray(payload) ? null : (payload?.domain ?? null);
      const round  = Array.isArray(payload) ? null : (payload?.round  ?? null);
      handleHintsForVote(hints, domain, round);
    });

    // Compat ancien event si jamais
    socket.on('allHints', ({ hints, domain, round }) => {
      const mapped = (hints || []).map(h => ({
        id: h.id,
        text: (typeof h.text === 'string') ? h.text : (h.hint || '')
      }));
      handleHintsForVote(mapped, domain, round);
    });

    // Mise √† jour serveur du compteur
    socket.on('phaseProgress', ({ phase, submitted, total }) => {
      if (phase === 'voting') {
        const elv = $('progress-vote'); if (elv) elv.textContent = `${submitted}/${total}`;
      }
    });

    socket.on('voteAck', () => {
      // Vote bien re√ßu
    });

    // Fermeture par le timer ‚Äî on verrouille les cartes
    socket.on('timer', ({ phase, leftMs }) => {
      if (phase === 'voting' && leftMs <= 0) {
        votingClosed = true;
        document.querySelectorAll('.vote-card').forEach(b => b.disabled = true);
      }
    });
  }

  function init() { initSocket(); }
  
  window.HOL.features = window.HOL.features || {};
  window.HOL.features.vote = { init };
})();

--- FICHIER : public/js/pwa/update.js ---
// Enregistre le SW, d√©tecte une MAJ et affiche le bandeau "Mettre √† jour"
(function () {
  if (!('serviceWorker' in navigator)) return;

  const BANNER_ID = 'update-banner';
  function ensureBanner() {
    if (document.getElementById(BANNER_ID)) return;
    const wrap = document.createElement('div');
    wrap.id = BANNER_ID;
    wrap.innerHTML = `
      <div class="update-card" role="status" aria-live="polite">
        <span>‚ú® Nouvelle version disponible</span>
        <div class="update-actions">
          <button id="update-reload" type="button">Mettre √† jour</button>
          <button id="update-dismiss" type="button" aria-label="Fermer">Plus tard</button>
        </div>
      </div>`;
    document.body.appendChild(wrap);
    document.getElementById('update-dismiss')?.addEventListener('click', () => wrap.remove());
    document.getElementById('update-reload')?.addEventListener('click', async () => {
      const regs = await navigator.serviceWorker.getRegistrations();
      regs.forEach(r => r.waiting?.postMessage({ type: 'SKIP_WAITING' }));
      // petit d√©lai puis reload
      setTimeout(() => location.reload(), 150);
    });
  }

  window.addEventListener('load', async () => {
    const reg = await navigator.serviceWorker.register('/sw.js').catch(() => null);
    if (!reg) return;

    function check(registration) {
      if (registration.waiting) {
        ensureBanner(); return;
      }
      registration.addEventListener('updatefound', () => {
        const sw = registration.installing;
        if (!sw) return;
        sw.addEventListener('statechange', () => {
          if (sw.state === 'installed' && navigator.serviceWorker.controller) ensureBanner();
        });
      });
    }
    check(reg);
    navigator.serviceWorker.addEventListener('controllerchange', () => {
      // on a pris la main ‚Üí on peut retirer le bandeau si pr√©sent
      document.getElementById(BANNER_ID)?.remove();
    });
  });
})();

--- FICHIER : public/sw.js ---
// --- Service Worker : Hint or Lie -------------------------------------------
// ‚ö†Ô∏è BUMPER LA VERSION √Ä CHAQUE DEPLOIEMENT (d√©clenche la mise √† jour PWA)
const CACHE = 'hol-v38';

// Liste des assets √† pr√©cacher (shell). Ajoute ici ce qui doit marcher offline.
const ASSETS = [
  '/',                // shell de nav
  '/index.html',
  '/style.css',

  // Images/ic√¥nes/manifest
  '/images/background-hero.svg?v=1', // <-- tu charges cette URL dans le CSS
  '/icons/icon-192.png',
  '/icons/icon-512.png',
  '/manifest.json',

  // CSS split
  '/css/01-tokens.css',
  '/css/02-base.css',
  '/css/03-components.css',
  '/css/04-phase.css',
  '/css/05-hints.css',
  '/css/06-vote.css',
  '/css/07-modal-score.css',
  '/css/98-responsive.css',
  '/css/99-pwa-update.css', // garde si tu utilises le bandeau de MAJ

 '/js/core/dom.js','/js/core/state.js','/js/core/socket.js',
  '/js/features/home.js','/js/features/hints.js','/js/features/vote.js',
  '/js/features/results.js','/js/features/leaderboard.js',
  '/js/pwa/update.js','/js/main.js',
];
// ---------------------------------------------------------------------------
// INSTALL : pr√©-cache + passe imm√©diatement en waiting
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE).then((cache) => cache.addAll(ASSETS))
  );
  self.skipWaiting();
});

// ACTIVATE : nettoyage des anciens caches + prise de contr√¥le imm√©diate
self.addEventListener('activate', (event) => {
  event.waitUntil(
    (async () => {
      const names = await caches.keys();
      await Promise.all(
        names.filter((n) => n !== CACHE).map((n) => caches.delete(n))
      );
      await self.clients.claim();
    })()
  );
});

// Messages depuis la page (ex: bouton "Mettre √† jour")
self.addEventListener('message', (event) => {
  const type = event?.data?.type;
  if (type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  if (type === 'GET_VERSION') {
    event.source?.postMessage({ type: 'SW_VERSION', cache: CACHE });
  }
});

// ---------------------------------------------------------------------------
// FETCH : strat√©gies par type de ressource
self.addEventListener('fetch', (event) => {
  const req = event.request;

  // On ne s occupe que des requ√™tes m√™me origine
  const url = new URL(req.url);
  if (url.origin !== self.location.origin) return;

  // 1) NAVIGATIONS : network-first avec fallback sur index.html du cache
  if (req.mode === 'navigate') {
    event.respondWith(networkFirstForNavigation(req));
    return;
  }

  // 2) CSS & JS : stale-while-revalidate (rapide + rafra√Æchi en arri√®re-plan)
  if (req.destination === 'style' || req.destination === 'script') {
    event.respondWith(staleWhileRevalidate(req));
    return;
  }

  // 3) IMAGES / FONTS / AUTRES : cache-first
  if (
    req.destination === 'image' ||
    req.destination === 'font' ||
    req.destination === 'manifest'
  ) {
    event.respondWith(cacheFirst(req));
    return;
  }

  // Par d√©faut : passe-through
});

// ---------------------------------------------------------------------------
// Helpers de strat√©gie

async function networkFirstForNavigation(req) {
  const cache = await caches.open(CACHE);
  try {
    // on tente la derni√®re version en ligne
    const fresh = await fetch(req, { cache: 'no-store' });
    // on garde aussi une copie d index.html pour le mode offline
    // (on met la vraie ressource en cache sous sa cl√© d URL)
    cache.put(req, fresh.clone());
    return fresh;
  } catch {
    // offline : on retombe sur le shell
    return (
      (await cache.match('/')) ||
      (await cache.match('/index.html')) ||
      Response.error()
    );
  }
}

async function staleWhileRevalidate(req) {
  const cache = await caches.open(CACHE);
  const cached = await cache.match(req);
  const fetchAndUpdate = fetch(req)
    .then((res) => {
      cache.put(req, res.clone());
      return res;
    })
    .catch(() => undefined);
  return cached || fetchAndUpdate || fetch(req);
}

async function cacheFirst(req) {
  const cache = await caches.open(CACHE);
  const cached = await cache.match(req);
  return cached || fetch(req).then((res) => {
    cache.put(req, res.clone());
    return res;
  });
}

--- FICHIER : routes/index.js ---
// routes/index.js
const express = require('express');
const router = express.Router();
const path = require('path');

// CORRECTIF DES CHEMINS POUR RENDER
const rootDir = path.join(__dirname, '..');

// 1. Import de la config
const config = require(path.join(rootDir, 'config', 'index.js'));

// 2. Import de l √©tat des salles (n√©cessaire pour certaines routes)
// On pointe bien vers sockets/state/room.js
const { rooms } = 
  require(path.join(rootDir, 'routes', 'sockets', 'state', 'room.js'));

// 3. Import du setup des Sockets (pour l exporter vers server.js)
const setupSockets = require('./sockets/index.js');

// --- TES ROUTES HTTP ---

// Route de test
router.get('/health', (req, res) => {
  res.json({ status: 'ok', rooms: rooms.size });
});

// --- EXPORT POUR SERVER.JS ---

// Cette fonction est celle que server.js appelle √† la ligne 15
function setupRoutes(app) {
  app.use('/', router);
}

// On exporte la fonction directement ET en tant que propri√©t√© pour √™tre s√ªr
module.exports = setupRoutes;
module.exports.setupRoutes = setupRoutes;
module.exports.setupSockets = setupSockets;

--- FICHIER : routes/sockets/index.js ---
// routes/sockets/index.js
const path = require('path');

const { HINT_SECONDS, VOTE_SECONDS, LOBBY_READY_SECONDS } =
  require(path.join(__dirname, '..', '..', 'config', 'index.js'));

const { rooms, snapshot, broadcast, createRoom } =
  require(path.join(__dirname, 'state', 'room.js'));

const { clearRoomTimer, startPhaseTimer } =
  require(path.join(__dirname, 'timer.js'));

const { isHintAllowed } =
  require(path.join(__dirname, 'game', 'validate.js'));

let makePersistence = () => ({
  upsertRoundResult: async () => {},
  applyPenaltyIfNotWinner: async () => ({ ok:false, reason:'no-db' }),
  getTop50:          async () => [],
  getMyStats:        async () => null,
});
try {
  makePersistence = require(path.join(__dirname, '..', 'utils', 'persistence.js')).makePersistence;
} catch {
  console.log('‚ÑπÔ∏è Persistence non branch√©e (utils/persistence.js introuvable).');
}

const { createController } =
  require(path.join(__dirname, 'game', 'controller.js'));

function normalizeLocal(s) {
  return String(s || '')
    .normalize('NFD').replace(/[ÃÄ-ÕØ]/g, '')
    .toLowerCase()
    .replace(/[^a-z0-9]+/gi, ' ')
    .trim().replace(/\s+/g, ' ');
}

module.exports = function setupSockets(io, db){
  const { upsertRoundResult, getTop50, getMyStats, applyPenaltyIfNotWinner } = makePersistence(db);
  const controller = createController({ io, upsertRoundResult, applyPenaltyIfNotWinner, HINT_SECONDS, VOTE_SECONDS });

  /**
   * Envoie un snapshot complet et CORRECT de l √©tat de la salle √† tous les clients.
   * Cette fonction remplace `broadcast()` qui est suspect√© d avoir un bug
   * dans la s√©rialisation de la liste des joueurs (oubli de l ID).
   * @param {SocketIO.Server} io - L instance du serveur Socket.IO.
   * @param {string} code - Le code de la salle.
   */
  function sendCorrectRoomState(io, code) {
    const r = rooms.get(code);
    if (!r) return;

    const roomState = {
      code: code,
      hostId: r.hostId,
      state: r.state,
      round: r.round || 0,
      players: Array.from(r.players.entries()).map(([id, p]) => ({
        id: id, name: p.name, score: p.score || 0, disconnected: !!p.disconnected,
      })),
    };
    io.to(code).emit('roomState', roomState);
  }

  io.on('connection',(socket)=>{
    let joined  = { code:null };
    let profile = { deviceId:null, lastPseudo:null };

    if (socket.onAny) socket.onAny((ev, ...args) => console.debug('‚üµ', socket.id, ev, ...args));

    socket.on('hello', ({ deviceId, pseudo } = {})=>{
      if (deviceId) profile.deviceId   = String(deviceId).slice(0,64);
      if (pseudo)   profile.lastPseudo = String(pseudo).slice(0,16);
    });

    socket.on('getLeaderboard', async ()=>{
      try{
        const top = await getTop50();
        const payload = top.map(x => ({
          deviceId: x.deviceId,
          pseudo:   x.lastPseudo || 'Joueur',
          wins:     Number(x.wins || 0),
          rp:       Number(x.rp || 0),
        }));
        socket.emit('leaderboard', payload);
        socket.emit('leaderboardData', payload);
      }catch{
        socket.emit('errorMsg','Impossible de charger le Top 50');
      }
    });

    socket.on('getMyStats', async ({ deviceId })=>{
      const doc = await getMyStats(String(deviceId||''));
      socket.emit('myStats', doc ? {
        rp:Number(doc.rp||0), rounds:Number(doc.rounds||0), wins:Number(doc.wins||0),
        winsCrew:Number(doc.winsCrew||0), winsImpostor:Number(doc.winsImpostor||0)
      } : { rp:0, rounds:0, wins:0, winsCrew:0, winsImpostor:0 });
    });

// ---- createRoom
    socket.on('createRoom', ({ name, deviceId, pseudo } = {}) => {
      try {
        console.log('[Socket] createRoom re√ßu - name:', name, 'pseudo:', pseudo, 'deviceId:', deviceId);
        const displayName = String(name || pseudo || profile.lastPseudo || 'Joueur').slice(0, 16);
        console.log('[Socket] displayName calcul√©:', displayName);
        
        const code = createRoom(socket.id, displayName);
        console.log('[Socket] Salle cr√©√©e avec le code:', code, 'pour socketId:', socket.id);

        socket.join(code);
        joined.code = code;
        profile.lastPseudo = displayName;
        profile.deviceId = String(deviceId || profile.deviceId || '').slice(0, 64) || null;

        const r = rooms.get(code);
        console.log('[Socket] Room trouv√©e?', r ? 'OUI' : 'NON');
        if (r && r.players.has(socket.id)) {
          r.players.get(socket.id).deviceId = profile.deviceId;
        }

        console.log('[Socket] √âmission de roomCreated avec code:', code);
        socket.emit('roomCreated', { code });
        sendCorrectRoomState(io, code);
      } catch (err) {
        console.error('[Error] Cr√©ation de salle √©chou√©e:', err);
        socket.emit('errorMsg', 'Erreur lors de la cr√©ation de la salle.');
      }
    });
    // ---- joinRoom
    socket.on('joinRoom', ({ code, name, deviceId, pseudo } = {})=>{
      code = String(code || '').trim();
      if (!/^\d{4}$/.test(code)) return socket.emit('errorMsg','Code invalide (4 chiffres)');
      const r = rooms.get(code); if (!r) return socket.emit('errorMsg','Salle introuvable');

      socket.join(code);
      joined.code = code;

      const displayName = String(name || pseudo || profile.lastPseudo || 'Joueur').slice(0,16);
      profile.lastPseudo = displayName;
      profile.deviceId   = String(deviceId || profile.deviceId || '').slice(0,64) || null;

      // Persistance: recherche d un joueur d√©connect√© avec le m√™me pseudo
      let disconnectedPlayerEntry = null;
      for (const [id, p] of r.players.entries()) {
        if (p.name === displayName && p.disconnected) {
          disconnectedPlayerEntry = [id, p];
          break;
        }
      }

      if (disconnectedPlayerEntry) {
        const [oldId, pData] = disconnectedPlayerEntry;
        r.players.delete(oldId); // Supprime l ancienne entr√©e
        if(r.active?.has(oldId)) {
          r.active.delete(oldId);
          // ‚ö†Ô∏è NE PAS r√©int√©grer imm√©diatement, le flag spectator sera restaur√© ci-dessous
        }
        // Restaure les donn√©es sur le nouveau socket.id
        pData.disconnected = false;
        pData.disconnectedSince = undefined;
        // ‚úÖ IMPORTANT : Ne pas r√©initialiser spectator ici - maintenir son √©tat pr√©c√©dent
        r.players.set(socket.id, pData);
        console.log(`[Socket] Joueur reconnect√©: ${displayName} (nouveau ID: ${socket.id})`);

        io.to(code).emit('system', { text: `üéâ ${displayName} est de retour !` });

        // ‚úÖ NOUVEAU : Envoyer l √©tat du jeu au client reconnect√©
        const gameState = {
          state: r.state,
          phase: r.state,
          round: r.round || 0,
          // ‚úÖ FIX: It√©rer sur `entries()` pour avoir l ID (la cl√©) et le joueur (la valeur).
          // `p.id` √©tait `undefined`, ce qui emp√™chait l affichage du joueur reconnect√©.
          players: Array.from(r.players.entries()).map(([id, p]) => ({
            id: id,
            name: p.name,
            score: p.score || 0,
            disconnected: !!p.disconnected
          })),
          scores: Object.fromEntries(
            Array.from(r.players.entries()).map(([id, p]) => [id, p.score || 0])
          )
        };
        socket.emit('gameStateSync', gameState);

        // ‚úÖ NOUVEAU : Si c √©tait un spectateur ET qu on est encore en partie ‚Üí rester spectateur
        if (r.state !== 'lobby' && pData.spectator) {
          socket.emit('spectatorMode', { 
            phase: r.state, 
            message: 'Vous continuez √† regarder la manche en cours.' 
          });
        }

      } else {
        // V√©rification de l unicit√© du pseudo pour les nouveaux joueurs
        const isPseudoTaken = Array.from(r.players.values()).some(p => !p.disconnected && p.name === displayName);
        if (isPseudoTaken) {
          socket.leave(code);
          joined.code = null;
          return socket.emit('errorMsg', 'Ce pseudo est d√©j√† pris, merci d en choisir un autre.');
        }

        r.players.set(socket.id, {
          name: displayName, hint:null, vote:null, isImpostor:false, score:0,
          deviceId: profile.deviceId,
          spectator: false  // ‚úÖ Nouveaux joueurs ne sont PAS spectateurs au d√©but
        });
      }

      // Rejoint en cours de manche ‚Üí spectateur
      if (r.state !== 'lobby') {
        const p = r.players.get(socket.id);
        if (p) p.spectator = true;  // ‚úÖ Marquer TOUS les arrivants en partie
        socket.emit('spectatorMode', { 
          phase: r.state, 
          message: 'Manche en cours. Vous rejoindrez la prochaine manche.' 
        });

        if (r.active && r.active.size) {
          if (r.state === 'hints') {
            const submitted = Array.from(r.active).filter(id => typeof r.players.get(id)?.hint === 'string').length;
            io.to(code).emit('phaseProgress', { phase:'hints', submitted, total: r.active.size });
          } else if (r.state === 'voting') {
            const submitted = Array.from(r.active).filter(id => !!r.players.get(id)?.vote).length;
            io.to(code).emit('phaseProgress', { phase:'voting', submitted, total: r.active.size });
          }
        }
      }

      socket.emit('roomJoined', { code });
      sendCorrectRoomState(io, code);

      r.lobbyReady ||= new Set();
      // ‚úÖ FIX: Le total doit refl√©ter les joueurs connect√©s, pas la taille de `r.players` qui peut contenir des joueurs d√©connect√©s.
      const connectedCount = Array.from(r.players.values()).filter(p => !p.disconnected).length;
      io.to(code).emit('lobbyReadyProgress', { ready: r.lobbyReady.size, total: connectedCount });
    });

    // ---- leaveRoom
    socket.on('leaveRoom', ()=>{
      const code = joined.code; if(!code) return;
      const r = rooms.get(code); if(!r) return;
      
      const me = r.players.get(socket.id);
      const name = me?.name || 'Un joueur';

      // Suppression d√©finitive du joueur
      r.players.delete(socket.id);
      if (r.active?.has(socket.id)) r.active.delete(socket.id);
      if (r.lobbyReady?.has(socket.id)) r.lobbyReady.delete(socket.id);
      if (r.readyNext?.has(socket.id)) r.readyNext.delete(socket.id);

      // Si la salle est vide, supprimez-la
      if (r.players.size === 0) {
        rooms.delete(code);
        socket.leave(code);
        joined.code = null;
        return;
      }

      // G√©rer le compte √† rebours du lobby si un joueur part
      if (r.timer?.phase === 'lobby') {
        clearRoomTimer(r);
        io.to(code).emit('lobbyCountdownCancelled');
      }

      // Transf√©rer l h√¥te si n√©cessaire
      if (r.hostId === socket.id) {
        const first = r.players.keys().next().value;
        if (first) r.hostId = first;
      }
      
      io.to(code).emit('system', { text: `üëã ${name} a quitt√© la partie.` });

      // Si on est en manche et que les actifs < 3 ‚Üí retour lobby
      const activePlayers = Array.from(r.players.values()).filter(p => !p.disconnected);
      if ((r.state === 'hints' || r.state === 'voting') && activePlayers.length < 3) {
        clearRoomTimer(r);
        for (const p of r.players.values()) {
          p.hint = null; p.vote = null; p.isImpostor = false;
        }
        r.state = 'lobby';
        r.lobbyReady = new Set();
        r.readyNext  = new Set();
        r.used = {};
        r.impostor = null;

        io.to(code).emit('lobbyCountdownCancelled');
        io.to(code).emit('errorMsg', 'Pas assez de joueurs actifs, retour au lobby');
      }

      socket.leave(code);
      joined.code = null;
      sendCorrectRoomState(io, code);
      socket.emit('leftRoom');
    });

    // ---- playerReadyLobby
    socket.on('playerReadyLobby', ({ ready }) =>{
      const r = rooms.get(joined.code); if(!r) return; if (r.state !== 'lobby') return;

      r.lobbyReady ||= new Set();
      if (ready) r.lobbyReady.add(socket.id); else r.lobbyReady.delete(socket.id);

      // ‚úÖ FIX: Le total doit refl√©ter les joueurs connect√©s, et non la taille de `r.players` qui peut contenir des joueurs d√©connect√©s.
      const connectedCount = Array.from(r.players.values()).filter(p => !p.disconnected).length;
      io.to(joined.code).emit('lobbyReadyProgress', { ready: r.lobbyReady.size, total: connectedCount });

      // ‚úÖ FIX: La condition de d√©marrage doit aussi utiliser le nombre de joueurs connect√©s pour √©viter un blocage.
      if (r.lobbyReady.size === connectedCount && connectedCount >= 3){
        clearRoomTimer(r);
        startPhaseTimer(io, joined.code, LOBBY_READY_SECONDS, 'lobby', ()=> controller.startRound(joined.code));
        io.to(joined.code).emit('lobbyCountdownStarted', { seconds: LOBBY_READY_SECONDS });
      } else if (r.timer?.phase === 'lobby'){
        clearRoomTimer(r);
        io.to(joined.code).emit('lobbyCountdownCancelled');
      }
    });

    // ---- startRound (host only)
    socket.on('startRound', ()=>{
      const r = rooms.get(joined.code); if(!r) return;
      if (r.hostId !== socket.id) return socket.emit('errorMsg',"Seul l h√¥te peut d√©marrer");
      controller.startRound(joined.code);
      socket.emit('actionAck', { action:'startRound', status:'ok' });
    });

    // ---- submitHint
    socket.on('submitHint', ({ hint })=>{
      const r = rooms.get(joined.code); if(!r || r.state!=='hints') return;
      if (r.state === 'gameOver') return socket.emit('errorMsg', 'La partie est termin√©e');
      const p = r.players.get(socket.id); if(!p) return;

      // ‚úÖ DOUBLE v√©rification spectateur
      if (p.spectator || !r.active?.has(socket.id)) return socket.emit('errorMsg', 'Tu participeras au prochain round (spectateur)');
      if (typeof p.hint === 'string') return;

      const raw = String(hint||'').trim().slice(0,40);

      const mySecret = r.words.common;
      const check = isHintAllowed(mySecret, raw, r.words.domain);
      if (!check.ok) return socket.emit('hintRejected', { reason: check.reason });

      r.usedHints ||= new Set();
      const key = normalizeLocal(raw);
      if (r.usedHints.has(key)) return socket.emit('hintRejected', { reason: "Indice d√©j√† utilis√© par un autre joueur." });
      r.usedHints.add(key);

      p.hint = raw;
      socket.emit('hintAck');

      if (!p.isImpostor) {
        r.liveCrewHints ||= [];
        const item = { id: socket.id, name: p.name, hint: raw };
        r.liveCrewHints.push({ name: p.name, hint: raw });

        if (r.impostor) {
          const impSock = io.sockets.sockets.get(r.impostor);
          if (impSock) impSock.emit('crewHintAdded', item);
          else io.to(r.impostor).emit('crewHintAdded', item);
        }
      }

      const submitted = Array.from(r.active).filter(id => typeof r.players.get(id)?.hint === 'string').length;
      io.to(joined.code).emit('phaseProgress', { phase:'hints', submitted, total: r.active.size });

      controller.maybeStartVoting(joined.code);
    });

    // ---- submitVote
    socket.on('submitVote', ({ hintId, targetId } = {}) => {
      const r = rooms.get(joined.code); if (!r || r.state !== 'voting') return;
      if (r.state === 'gameOver') return socket.emit('errorMsg', 'La partie est termin√©e');
      const me = r.players.get(socket.id); if (!me) return;

      // ‚úÖ DOUBLE v√©rification spectateur
      if (me.spectator || !r.active?.has(socket.id)) {
        return socket.emit('errorMsg', 'Tu voteras √† la prochaine manche (spectateur)');
      }

      const voteVal = hintId || targetId;
      if (!voteVal) return;

      // ‚úÖ Utilisation du contr√¥leur pour centraliser la logique (vote + fin anticip√©e)
      controller.handleVote(joined.code, socket.id, voteVal);
      socket.emit('voteAck');
    });

    // ---- playerReadyNext (reveal -> manche suivante)
    socket.on('playerReadyNext', ()=>{
      const r = rooms.get(joined.code); if(!r) return; if (r.state !== 'reveal') return;
      r.readyNext ||= new Set();
      r.readyNext.add(socket.id);
      const activeCount = Array.from(r.players.values()).filter(p => !p.disconnected).length;
      io.to(joined.code).emit('readyProgress', { ready: r.readyNext.size, total: activeCount });
      if (r.readyNext.size >= activeCount && activeCount > 0){
        startPhaseTimer(io, joined.code, 3, 'prestart', ()=> controller.startRound(joined.code));
      }
    });

    // ---- resetScores (host only)
    socket.on('resetScores', ()=>{
      const r = rooms.get(joined.code); if(!r) return;
      if (r.hostId !== socket.id) return socket.emit('errorMsg',"Seul l h√¥te peut r√©initialiser");
      for (const p of r.players.values()) p.score = 0;
      r.round = 0; r.state='lobby'; r.used={}; r.lobbyReady = new Set(); r.readyNext = new Set();
      clearRoomTimer(r);
      io.to(joined.code).emit('lobbyCountdownCancelled');
      io.to(joined.code).emit('scoresReset');
      sendCorrectRoomState(io, joined.code);
    });

    // ---- disconnect
    socket.on('disconnect', () => {
      const code = joined.code; if (!code) return;
      const r = rooms.get(code); if (!r) return;

      const me = r.players.get(socket.id);
      if (!me) return; // Joueur d√©j√† supprim√© ou jamais vraiment ajout√©

      me.disconnected = true;
      me.disconnectedSince = r.round;
      const name = me.name || 'Un joueur';
      const wasHost = (r.hostId === socket.id);
      const wasImpostor = !!me.isImpostor;

      // Ne pas supprimer le joueur, juste le marquer.
      // Le nettoyage se fera au d√©but des manches.

      // si plus personne D ACTIF ‚Üí supprimer la room
      const activePlayers = Array.from(r.players.values()).filter(p => !p.disconnected);
      if (activePlayers.length === 0) {
        rooms.delete(code);
        return;
      }

      // transfert d h√¥te si besoin
      if (wasHost) {
        const firstActive = Array.from(r.players.entries()).find(([id, p]) => !p.disconnected);
        if (firstActive) {
          r.hostId = firstActive[0];
        }
      }

      // message syst√®me
      io.to(code).emit('system', { text: `üëã ${name} a quitt√© la partie` });

      // Mettre √† jour le nombre total de joueurs (uniquement les actifs)
      const totalPlayers = activePlayers.length;
      if (r.lobbyReady) {
        io.to(code).emit('lobbyReadyProgress', { ready: r.lobbyReady.size, total: totalPlayers });
      }
      if (r.readyNext) {
        io.to(code).emit('readyProgress', { ready: r.readyNext.size, total: totalPlayers });
      }


      // si on est en manche et que les actifs < 3 ‚Üí retour lobby imm√©diat
      const activeInGame = Array.from(r.active || []).filter(id => !r.players.get(id)?.disconnected);
      if ((r.state === 'hints' || r.state === 'voting') && activeInGame.length < 3) {
        clearRoomTimer(r);
        for (const id of r.players.keys()) {
          const p = r.players.get(id);
          if (p && !p.disconnected) { p.hint = null; p.vote = null; p.isImpostor = false; }
        }
        r.state = 'lobby';
        r.lobbyReady = new Set();
        r.readyNext  = new Set();
        r.used = {};
        r.impostor = null;

        io.to(code).emit('lobbyCountdownCancelled');
        io.to(code).emit('errorMsg', 'Pas assez de joueurs actifs, retour au lobby');
        sendCorrectRoomState(io, code);
        return;
      }

      // r√©concilier la phase en cours (compteurs avec r.active)
      if (r.state === 'hints') {
        const activeConnected = Array.from(r.active).filter(id => !r.players.get(id)?.disconnected);
        const submitted = activeConnected.filter(id => typeof r.players.get(id)?.hint === 'string').length;
        io.to(code).emit('phaseProgress', { phase:'hints', submitted, total: activeConnected.length });
        if (submitted === activeConnected.length && activeConnected.length > 0) {
          controller.maybeStartVoting(code);
        }
      } else if (r.state === 'voting') {
        const activeConnected = Array.from(r.active).filter(id => !r.players.get(id)?.disconnected);
        const submitted = activeConnected.filter(id => !!r.players.get(id)?.vote).length;
        io.to(code).emit('phaseProgress', { phase:'voting', submitted, total: activeConnected.length });
        if (submitted === activeConnected.length && activeConnected.length > 0) {
          controller.finishVoting(code);
        }
      }

      if (wasImpostor && (r.state === 'hints' || r.state === 'voting')) {
        // ... la logique de victoire des √©quipiers reste la m√™me
        clearRoomTimer(r);
        for (const id of r.active || []) {
          const p = r.players.get(id);
          if (p && !p.isImpostor && !p.disconnected) p.score = (p.score || 0) + 1;
        }

        io.to(code).emit('roundResult', {
          round: r.round,
          impostorId: socket.id,
          impostorName: name,
          common: r.words?.common,
          impostor: null,
          impostorHint: null,
          commonDisplay: r.words?.common,
          impostorDisplay: "‚Äî",
          votes: {},
          impostorCaught: true,
          domain: r.words?.domain
        });

        r.state = 'reveal';
        r.readyNext = new Set();
        io.to(code).emit('readyProgress', { ready: 0, total: totalPlayers });

        const scores = Array.from(r.players.values()).filter(p => !p.disconnected).map(p => p.score || 0);
        const maxScore = Math.max(0, ...scores);
        if (maxScore >= 10) {
           const winnersArr = Array.from(r.players.entries())
            .filter(([_, p]) => !p.disconnected && (p.score || 0) === maxScore)
            .map(([id, p]) => ({ id, name: p.name, score: p.score || 0 }));
          io.to(code).emit('gameOver', { winners: winnersArr, round: r.round, autoReset: true });

          for (const p of r.players.values()) { p.score = 0; p.hint = null; p.vote = null; p.isImpostor = false; p.spectator = false; }
          r.round = 0; r.state = 'lobby'; r.lobbyReady = new Set(); r.readyNext = new Set(); r.used = {};
          clearRoomTimer(r);
        }
      }

      sendCorrectRoomState(io, code);
    });
  });
};

--- FICHIER : routes/sockets/persistence.js ---
// routes/utils/persistence.js
function makePersistence(db) {
  // Fallback si pas de DB (no-op s√ªr)
  if (!db) {
    return {
      upsertRoundResult:        async () => {},
      applyPenaltyIfNotWinner:  async () => ({ ok:false, reason:'no-db' }),
      getTop50:                 async () => [],
      getMyStats:               async () => null,
    };
  }

  const admin = require('firebase-admin');
  const { getHlRank, getPenaltyByRank } = require('./hlrank');

  // Enregistre les points gagn√©s sur la MANCHE (tes r√®gles actuelles)
  async function upsertRoundResult({ deviceId, pseudo, didWin, isImpostor }) {
    try {
      const ref = db.collection('players').doc(String(deviceId));
      await db.runTransaction(async (tx) => {
        const snap = await tx.get(ref);
        const prev = snap.exists ? (snap.data() || {}) : {};

        const prevRP = Number(prev.rp || 0);
        const delta = didWin ? (isImpostor ? 3 : 1) : 0; // (tu ne mettais pas de malus par manche)
        let newRP = prevRP + delta;

        tx.set(ref, {
          deviceId: String(deviceId),
          lastPseudo: String(pseudo || prev.lastPseudo || 'Joueur').slice(0, 16),
          rounds: Number(prev.rounds || 0) + 1,
          wins: Number(prev.wins || 0) + (didWin ? 1 : 0),
          winsCrew: Number(prev.winsCrew || 0) + (didWin && !isImpostor ? 1 : 0),
          winsImpostor: Number(prev.winsImpostor || 0) + (didWin && isImpostor ? 1 : 0),
          rp: newRP,
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        }, { merge: true });
      });
    } catch (e) {
      console.error('upsertRoundResult error', e);
    }
  }

  // P√©nalit√© de FIN DE PARTIE (non-vainqueurs), bas√©e sur le rang AVANT p√©nalit√©
  async function applyPenaltyIfNotWinner({ deviceId, pseudo }) {
    try {
      const ref = db.collection('players').doc(String(deviceId));
      let result = null;

      await db.runTransaction(async (tx) => {
        const snap = await tx.get(ref);
        const prev = snap.exists ? (snap.data() || {}) : {};
        const rpBefore = Number(prev.rp || 0);
        const rankBefore = getHlRank(rpBefore);
        const penalty = getPenaltyByRank(rankBefore);
        const rpAfter = Math.max(0, rpBefore - penalty);

        tx.set(ref, {
          deviceId: String(deviceId),
          lastPseudo: String(pseudo || prev.lastPseudo || 'Joueur').slice(0, 16),
          rp: rpAfter,
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        }, { merge: true });

        result = { ok: true, rpBefore, rankBefore, penalty, rpAfter };
      });

      return result || { ok:false, reason:'txn' };
    } catch (e) {
      console.error('applyPenaltyIfNotWinner error', e);
      return { ok:false, reason: e.message };
    }
  }

  async function getTop50() {
    try {
      const qs = await db.collection('players')
        .orderBy('rp', 'desc')
        .orderBy('wins', 'desc')
        .limit(50)
        .get();
      return qs.docs.map(d => ({ deviceId: d.id, ...(d.data() || {}) }));
    } catch (e) {
      console.error('getTop50 error', e);
      return [];
    }
  }

  async function getMyStats(deviceId) {
    try {
      const snap = await db.collection('players').doc(String(deviceId)).get();
      return snap.exists ? (snap.data() || {}) : null;
    } catch (e) {
      console.error('getMyStats error', e);
      return null;
    }
  }

  return { upsertRoundResult, applyPenaltyIfNotWinner, getTop50, getMyStats };
}

module.exports = { makePersistence };

--- FICHIER : routes/sockets/timer.js ---
// routes/sockets/timer.js
const path = require('path');

// ‚úÖ chemin corrig√©: state/room.js
const { rooms: _rooms } =
  require(path.join(__dirname, 'state', 'room.js'));

function clearRoomTimer(room){
  if (room?.timer?.interval) clearInterval(room.timer.interval);
  if (room) room.timer = { interval:null, deadline:0, phase:null };
}

function startPhaseTimer(io, code, seconds, phase, onExpire){
  const room = _rooms.get(code); if(!room) return;
  clearRoomTimer(room);
  const deadline = Date.now() + seconds*1000;
  const totalMs = seconds * 1000;

  const thisTimerInterval = setInterval(()=>{
    const currentRoom = _rooms.get(code);
    if (!currentRoom) {
        clearInterval(thisTimerInterval);
        return;
    }

    // If the room's current timer isn't this one, this one is stale and should just stop.
    if (currentRoom.timer.interval !== thisTimerInterval) {
        clearInterval(thisTimerInterval);
        return;
    }

    const leftMs = Math.max(0, deadline - Date.now());
    io.to(code).emit('timer', { phase, leftMs, totalMs });

    if (leftMs <= 0){
      // This timer is expiring. Clear it from the room state BEFORE calling onExpire.
      // This prevents onExpire from clearing a *new* timer if it creates one.
      clearInterval(thisTimerInterval);
      currentRoom.timer = { interval:null, deadline:0, phase:null };

      // Now call the original callback.
      onExpire?.();
    }
  }, 500);

  // Store the new timer's identity in the room.
  room.timer = { interval: thisTimerInterval, deadline, phase };
}

module.exports = { clearRoomTimer, startPhaseTimer };

--- FICHIER : routes/sockets/game/controller.js ---
// routes/sockets/game/controller.js
const path = require('path');

const { rooms, broadcast } =
  require(path.join(__dirname, '..', 'state', 'room.js'));
const { labelWordByDomain } =
  require(path.join(__dirname, 'words.js'));
const { pickPair } =
  require(path.join(__dirname, 'picker.js'));
const { clearRoomTimer, startPhaseTimer } =
  require(path.join(__dirname, '..', 'timer.js'));

function createController({ io, upsertRoundResult, applyPenaltyIfNotWinner, HINT_SECONDS, VOTE_SECONDS }) {

  function startRound(code) {
    const r = rooms.get(code); if (!r) return;

    // Nettoyage des joueurs d√©connect√©s depuis trop longtemps
    for (const [id, p] of r.players.entries()) {
      if (p.disconnected && (r.round - p.disconnectedSince) >= 2) {
        r.players.delete(id);
        if(r.active?.has(id)) r.active.delete(id);
        console.log(`[GC] Joueur ${p.name} (id: ${id}) supprim√© pour inactivit√© prolong√©e.`);
      }
    }
    
    // ‚úÖ R√âINITIALISER TOUS les flags de spectateur au d√©but du round
    for (const p of r.players.values()) {
      p.spectator = false;  // Tout le monde devient potentiellement actif
    }

    clearRoomTimer(r);
    r.lobbyReady = new Set();
    r.readyNext  = new Set();

    // Fige les joueurs actifs pour TOUT le round (ceux qui ne sont pas d√©connect√©s, y compris les ex-spectateurs)
    r.active = new Set(Array.from(r.players.entries()).filter(([_, p]) => !p.disconnected).map(([id]) => id));

    if (r.active.size < 3) {
      io.to(code).emit('errorMsg', 'Minimum 3 joueurs');
      r.state = 'lobby';
      return broadcast(io, code);
    }

    // Reset des √©tats de round (par joueur)
    for (const p of r.players.values()) {
      p.hint = null;
      p.vote = null;
      p.isImpostor = false;
    }

    // === NEW: structures pour vote par indice anonyme ===
    r.hints = [];                 // [{ id, playerId, text, ts }]
    r.hintAuthor = new Map();     // hintId -> playerId

    // Tirage des mots (imposteur n a PAS de mot)
    const pair = pickPair(r);
    r.words = { common: pair.common, impostor: null, domain: pair.domain };
    r.lastDomain = pair.domain;
    r.lastCommon = pair.common;

    // Choix de l imposteur parmi les actifs
    const activeIds = Array.from(r.active);
    const impId = activeIds[Math.floor(Math.random() * activeIds.length)];
    r.impostor = impId;
    const imp = r.players.get(impId);
    if (imp) imp.isImpostor = true;

    r.usedHints = new Set();
    r.liveCrewHints = [];

    r.round = (r.round || 0) + 1;
    r.state = 'hints';

    // Envoi des infos de manche aux ACTIFS
    for (const id of r.active) {
      const p = r.players.get(id);
      if (!p) continue;

      if (p.isImpostor) {
        io.to(id).emit('roundInfo', {
          word: null,
          wordDisplay: 'Aucun mot ‚Äî observe les indices',
          isImpostor: true,
          domain: r.words.domain,
          round: r.round,
        });
      } else {
        const myword = r.words.common;
        io.to(id).emit('roundInfo', {
          word: myword,
          wordDisplay: labelWordByDomain(myword, r.words.domain),
          isImpostor: false,
          domain: r.words.domain,
          round: r.round,
        });
      }
    }

    // L imposteur re√ßoit le flux live des indices d √©quipiers
    if (r.impostor) io.to(r.impostor).emit('crewHintsLive', { hints: r.liveCrewHints });

    // Progress initial
    io.to(code).emit('phaseProgress', { phase: 'hints', submitted: 0, total: r.active.size, round: r.round });

    // Timer phase indices
    startPhaseTimer(io, code, HINT_SECONDS, 'hints', () => {
      const room = rooms.get(code); if (!room) return;
      // Hints vides pour les ACTIFS qui n ont rien envoy√©
      for (const id of room.active) {
        const p = room.players.get(id);
        if (p && typeof p.hint !== 'string') p.hint = '';
      }
      maybeStartVoting(code);
    });

    broadcast(io, code);
  }

  function maybeStartVoting(code) {
    const r = rooms.get(code); if (!r) return;
    if (r.state !== 'hints') return;
    // Ne compte que les joueurs actifs et connect√©s
    const activeConnected = Array.from(r.active || []).filter(id => !r.players.get(id)?.disconnected);
    const submitted = activeConnected.filter(id => typeof r.players.get(id)?.hint === 'string').length;
    const total = activeConnected.length;

    if (submitted === total && total > 0) {
      clearRoomTimer(r);
      r.state = 'voting';

      // === NEW: reconstruire la liste d indices anonymes + mapping auteur ===
      r.hints = [];
      r.hintAuthor = new Map();
      const now = Date.now();

      // On inclut les indices de tous les joueurs du set `active` original, m√™me d√©connect√©s
      for (const id of r.active) {
        const p = r.players.get(id);
        if (!p || typeof p.hint !== 'string') continue; // Ne pas inclure si le joueur a √©t√© purg√© ou n a pas jou√©
        const text = p.hint.trim();
        const hid  = `H_${r.round || 1}_${id}`;
        r.hints.push({ id: hid, playerId: id, text, ts: now });
        r.hintAuthor.set(hid, id);
      }

      // === NEW: payload anonyme (tableau) pour compat client ===
      const hintsPayload = r.hints.map(h => ({ id: h.id, hint: h.text }));
      io.to(code).emit('hintsList', hintsPayload);

      startPhaseTimer(io, code, VOTE_SECONDS, 'voting', () => finishVoting(code));
      broadcast(io, code);
    } else {
      // Mise √† jour de la progression si tout le monde n a pas encore soumis
      io.to(code).emit('phaseProgress', { phase: 'hints', submitted, total, round: r.round });
    }
  }

  // ‚úÖ NOUVEAU : Gestion du vote unitaire pour fin anticip√©e
  function handleVote(code, playerId, voteId) {
    const r = rooms.get(code);
    if (!r || r.state !== 'voting') return;

    const p = r.players.get(playerId);
    if (!p) return;

    p.vote = voteId; // On stocke l id de l indice (sera converti dans finishVoting)

    const activeConnected = Array.from(r.active || []).filter(id => !r.players.get(id)?.disconnected);
    const submitted = activeConnected.filter(id => r.players.get(id)?.vote).length;
    const total = activeConnected.length;

    io.to(code).emit('phaseProgress', { phase: 'voting', submitted, total, round: r.round });

    if (submitted === total && total > 0) {
      finishVoting(code);
    }
  }

  function finishVoting(code) {
    const r = rooms.get(code); if (!r) return;
    if (r.state !== 'voting') return;

    clearRoomTimer(r);

    const activeConnected = Array.from(r.active || []).filter(id => !r.players.get(id)?.disconnected);
    const impId = r.impostor;

    // === NEW: conversion √©ventuelle des votes "hintId" -> "playerId"
    if (r.hintAuthor && typeof r.hintAuthor.get === 'function') {
      for (const id of activeConnected) {
        const p = r.players.get(id);
        if (p?.vote && r.hintAuthor.has(p.vote)) {
          p.vote = r.hintAuthor.get(p.vote);
        }
      }
    }

    // Tally des votes (sur playerId) - uniquement des joueurs connect√©s
    const tally = {};
    for (const id of activeConnected) {
      const p = r.players.get(id);
      if (p?.vote) tally[p.vote] = (tally[p.vote] || 0) + 1;
    }

    // üëâ D√©masqu√© SEULEMENT si top unique ET que c est l imposteur
    let max = -1;
    let leaders = [];
    for (const [candidate, v] of Object.entries(tally)) {
      if (v > max) { max = v; leaders = [candidate]; }
      else if (v === max) { leaders.push(candidate); }
    }
    const caught = (leaders.length === 1 && leaders[0] === impId);

    // Attribution des points
    if (caught) {
      for (const id of activeConnected) {
        const p = r.players.get(id);
        if (p && !p.isImpostor) p.score = (p.score || 0) + 1;
      }
    } else {
      const imp = r.players.get(impId);
      if (imp) imp.score = (imp.score || 0) + 2;
    }

    // D√©termination des vainqueurs de la manche
    const winners = new Set();
    if (caught) {
      for (const id of activeConnected) {
        if (!r.players.get(id)?.isImpostor) winners.add(id);
      }
    } else if (impId) {
      winners.add(impId);
    }

    // Persistance (si Firestore branch√©)
    for (const id of activeConnected) {
       const p = r.players.get(id);
       const didWin = winners.has(id);
       if (p?.deviceId) {
         upsertRoundResult?.({ deviceId: p.deviceId, pseudo: p.name, didWin, isImpostor: !!p.isImpostor });
       }
    }
// ... (apr√®s calcul de `caught`, attribution des points, winners, etc.)

// üëâ R√©cup√®re l indice (mensonge) tap√© par l imposteur pour l afficher dans le r√©sum√©
const impostorHint =
  (Array.isArray(r.hints) ? r.hints.find(h => h.playerId === impId)?.text : '') || '‚Äî';

// R√©sultat de manche ‚Äî version officielle
const votesDetail = {};
for (const id of activeConnected) {
  const p = r.players.get(id);
  if (p?.vote) {
    votesDetail[id] = p.vote;
  }
}
io.to(code).emit('roundResult', {
  round: r.round,
  impostorId: impId,
  impostorName: r.players.get(impId)?.name || '?',
  common: r.words?.common,
  impostor: null,                        // l imposteur n a pas de mot dans ta V2
  impostorHint,                          // ‚úÖ NOUVEAU
  commonDisplay: labelWordByDomain(r.words?.common, r.words?.domain),
  impostorDisplay: '‚Äî',
  votes: tally,
  votesDetail: votesDetail,
  impostorCaught: caught,
  domain: r.words?.domain,
});

    // ‚úÖ V√âRIFICATION FIN DE PARTIE (10 pts)
    const activePlayers = Array.from(r.players.entries()).filter(([_, p]) => !p.disconnected);
    const maxScore = Math.max(0, ...activePlayers.map(([_, p]) => p.score || 0));
    const isGameOver = maxScore >= 10;

    if (!isGameOver) {
      // === CONTINUATION : passer √† reveal ===
      r.state = 'reveal';
      r.readyNext = new Set();
      io.to(code).emit('readyProgress', { ready: 0, total: activePlayers.length });
      
      // ‚úÖ Broadcaster maintenant pour que le client sorte de l √©cran de vote
      broadcast(io, code);
      // On attend maintenant que les joueurs cliquent sur "Pr√™t" (g√©r√© par playerReadyNext dans index.js)

    } else {
      // === FIN DE PARTIE : Gagnants finaux ===
      const winnersArr = activePlayers
        .filter(([_, p]) => (p.score || 0) === maxScore)
        .map(([id, p]) => ({ id, name: p.name, score: p.score || 0, deviceId: p.deviceId }));

      // ‚úÖ Appliquer les p√©nalit√©s de fin de partie
      if (typeof applyPenaltyIfNotWinner === 'function') {
        const winnerIds = new Set(winnersArr.map(w => w.id));
        for (const [id, p] of activePlayers) {
          if (!winnerIds.has(id) && p?.deviceId) {
            applyPenaltyIfNotWinner({ deviceId: p.deviceId, pseudo: p.name })
              .catch(() => {}); // Silencieux
          }
        }
      }

      // √âtat final
      r.state = 'gameOver';

      // Signal gameOver avec contexte complet
      io.to(code).emit('gameOver', {
        winners: winnersArr,
        round: r.round,
        finalScores: Object.fromEntries(activePlayers.map(([id, p]) => [id, p.score || 0])),
        winnersCount: winnersArr.length,
        isGameOver: true,
      });

      // Reset pour la prochaine partie
      for (const p of r.players.values()) {
        p.score = 0;
        p.hint = null;
        p.vote = null;
        p.isImpostor = false;
        p.spectator = false;
      }
      r.round = 0;
      r.state = 'lobby';
      r.lobbyReady = new Set();
      r.readyNext = new Set();
      r.used = {};
      r.impostor = null;

      // Notify everyone
      broadcast(io, code);
    }
  }

  return { startRound, maybeStartVoting, finishVoting, handleVote };
}

module.exports = { createController };

--- FICHIER : routes/sockets/game/picker.js ---
// routes/sockets/game/picker.js
const path = require('path');

const { DOMAINS } =
  require(path.join(__dirname, 'words.js'));
const { pick } =
  require(path.join(__dirname, '..', 'utils', 'random.js'));

// Tirage "unique" sans clusters, avec anti-doublons + anti r√©p√©tition imm√©diate
function pickPair(room) {
  room.used ||= {};
  room.lastDomains ||= [];
  const cooldown = room.domainCooldown ?? 1;

  const all = Object.keys(DOMAINS);
  const validDomains = all.filter(d => (DOMAINS[d]?.length || 0) >= 2);
  if (!validDomains.length) return { common: 'Erreur', impostor: 'Erreur', domain: 'Aucun domaine' };

  // √©vite de reprendre le m√™me domaine trop souvent (cooldown)
  const banned = new Set(room.lastDomains.slice(-cooldown));
  const candidates = validDomains.filter(d => !banned.has(d));
  const domain = (candidates.length ? pick(candidates) : pick(validDomains));

  room.used[domain] ||= new Set();
  const usedSet = room.used[domain];

  // anti-doublons: on privil√©gie les mots jamais sortis; sinon on rouvre le pool
  const pool0 = DOMAINS[domain].slice();
  let pool = pool0.filter(w => !usedSet.has(w));
  if (pool.length < 2) pool = pool0.slice();

  // mot commun: √©viter de retomber deux fois de suite sur le m√™me
  let common = pick(pool);
  let guard = 0;
  while (common === room.lastCommon && pool.length > 1 && guard++ < 10) {
    common = pick(pool);
  }

  // imposteur ‚â† commun; fallback si n√©cessaire
  let impostorChoices = pool.filter(w => w !== common);
  if (!impostorChoices.length) impostorChoices = pool0.filter(w => w !== common);
  const impostor = pick(impostorChoices);

  // marquer comme utilis√©s
  usedSet.add(common);
  usedSet.add(impostor);

  room.lastCommon = common;
  room.lastDomains.push(domain);
  if (room.lastDomains.length > 5) room.lastDomains.shift();

  return { common, impostor, domain };
}

module.exports = { pickPair };

--- FICHIER : routes/sockets/game/validate.js ---
// routes/sockets/game/validate.js
const deburr = (s='') => s.normalize('NFD').replace(/[ÃÄ-ÕØ]/g,'');
const normalize = (s='') =>
  deburr(String(s).toLowerCase()).replace(/[^a-z0-9 ]+/g,' ').replace(/\s+/g,' ').trim();

function levenshtein(a,b){
  a = normalize(a); b = normalize(b);
  const m=a.length, n=b.length; if(!m) return n; if(!n) return m;
  const dp = Array.from({length:m+1},()=>Array(n+1).fill(0));
  for(let i=0;i<=m;i++) dp[i][0]=i; for(let j=0;j<=n;j++) dp[0][j]=j;
  for(let i=1;i<=m;i++) for(let j=1;j<=n;j++)
    dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+(a[i-1]===b[i-1]?0:1));
  return dp[m][n];
}

function isHintAllowed(secretWord, hint, domain){
  const h = normalize(hint);
  const w = normalize(secretWord);
  if (!h) return { ok:false, reason:"Indice vide." };
  const plurals = new Set([w, w+'s', w+'es']);
  if (plurals.has(h)) return { ok:false, reason:"Indice identique au mot." };
  const wordsInHint = new Set(h.split(' '));
  if (wordsInHint.has(w) || wordsInHint.has(w+'s') || wordsInHint.has(w+'es')) return { ok:false, reason:"Tu as utilis√© le mot lui-m√™me." };
  if (h.includes(w) && w.length>=4) return { ok:false, reason:"Indice trop proche du mot." };
  if (w.length>=5 && levenshtein(w,h) <= 2) return { ok:false, reason:"Indice presque identique." };
  const dom = normalize(domain||'');
  const domTokens = dom.split(' ').filter(Boolean);
  const banned = new Set();
  for (const t of domTokens){ banned.add(t); if (t.endsWith('es')) banned.add(t.slice(0,-2)); if (t.endsWith('s')) banned.add(t.slice(0,-1)); }
  if (banned.has(h)) return { ok:false, reason:"N utilise pas le nom du th√®me." };
  for (const token of wordsInHint){ if (banned.has(token)) return { ok:false, reason:"Indice trop proche du th√®me." }; }
  return { ok:true };
}

module.exports = { deburr, normalize, levenshtein, isHintAllowed };

--- FICHIER : routes/sockets/game/words.js ---
// --- sockets/game/words.js ---
const DOMAINS = {
  "Fruits Fleurs L√©gumes": [
    "Mangue","Papaye","Ananas","Banane","Pomme","Poire","Raisin","Myrtille",
    "Past√®que","Melon","Citron","Orange","Kiwi","Fraise","Noix de coco","Concombre",
    "Tomate","Poivron","Oignons","Hibiscus","Tipanier (frangipanier)","Rose","Corossol",
    "Laitue","Carotte","Aubergine","Courgette","Basilic"
  ],
  "Animaux": [
    "Chat","Chien","Tortue","Kangourou","Dauphin","Requin","Panda","Koala","Tigre",
    "Lion","Perroquet","Toucan","Cheval","Z√®bre","Aigle","Faucon","Loutre","Castor",
    "Grenouille","Serpent","Souris","Poisson","H√©risson"
  ],
  "Villes": [
    "Paris","Londres","Tokyo","Osaka","New York","Los Angeles","Rome","Ath√®nes",
    "Madrid","Barcelone","Berlin","Munich","Rio","S√£o Paulo","Sydney","Melbourne",
    "Montr√©al","Toronto","Le Caire","Alexandrie","Duba√Ø","Abu Dhabi","Manchester"
  ],
  "Pays": [
    "France","Japon","Br√©sil","Canada","√âgypte","Italie","Espagne","Allemagne",
    "Australie","Maroc","Mexique","√âtats-Unis","Chine","Inde","Royaume-Uni"
  ],
  "Sports": [
    "Football","Rugby","Tennis","Badminton","Basket","Handball","Boxe","Kung-fu",
    "Formule 1","Rallye","Surf","Voile","Cyclisme","VTT (V√©lo tout-terrain)","Ski","Snowboard","Golf",
    "Cricket","Danse"
  ],
  "Objets": [
    "Chaise","Tabouret","Table","Bureau","T√©l√©phone","Tablette","Ordinateur","Console",
    "Cl√©","Serrure","Lampe","Bougie","Valise","Sac √† Dos","Montre","Bracelet","Lunettes",
    "Casque","Stylo","Crayon","Tasse","Verre","Ciseaux","Cutter"
  ],
  "Nature": [
    "Plage","Montagne","For√™t","D√©sert","Lac","Rivi√®re","√éle","Continent","Volcan",
    "Glacier","Cascade","Geyser","Ciel","Oc√©an","Soleil","Lune"
  ],
  "M√©tiers": [
    "M√©decin","Infirmier","Professeur","Pompier","Policier","Cuisinier",
    "Serveur","Pilote","H√¥tesse de l Air","Architecte","Ing√©nieur",
    "Boulanger","Plombier","√âlectricien","V√©t√©rinaire"
  ],
  "Transports": [
    "Voiture","Moto","Bus","Tram","Train","M√©tro","Avion","H√©licopt√®re","Bateau",
    "Voilier","V√©lo","Trottinette","Jet-sky","Sous-marin","Mongolfi√®re","Deltaplane"
  ],
  "Couleurs Formes": [
    "Rouge","Orange","Bleu","Cyan","Vert","Vert citron","Noir","Gris","Blanc","Ivoire",
    "Cercle","Ellipse","Carr√©","Rectangle","Triangle","Pyramide"
  ],
  "Cin√©ma": [
    "Star Wars","Harry Potter","Le Seigneur des Anneaux","Marvel","DC Comics","Batman",
    "Superman","Iron Man","Captain America","Avengers","Black Panther","Doctor Strange",
    "Spider-Man","Hulk","Joker","Wonder Woman","Aquaman","The Flash","Avatar","Titanic",
    "Jurassic Park","Jurassic World","Indiana Jones","Matrix","Inception","Interstellar",
    "Le Roi Lion","La Reine des Neiges","Toy Story","Cars","Coco","Vice-Versa","Les Indestructibles"
  ],
  "Manga": [
    "Naruto","One Piece","Dragon Ball","Bleach","Pok√©mon","My Hero Academia","Attack on Titan",
    "Death Note","Fullmetal Alchemist","One Punch Man","Demon Slayer","Jujutsu Kaisen",
    "Hunter x Hunter","Fairy Tail","Black Clover","Chainsaw Man"
  ],
  "Personnalit√©s": [
    "Beyonc√©","Rihanna","Cristiano Ronaldo","Lionel Messi","Taylor Swift","Ariana Grande",
    "Keanu Reeves","Tom Cruise","Elon Musk","Jeff Bezos","Drake","The Weeknd","Shakira",
    "Eminem","Adele","Lady Gaga","Robert Downey Jr.","Chris Hemsworth","Scarlett Johansson",
    "Zendaya","Dwayne Johnson","Jason Momoa","Serena Williams","Roger Federer","Michael Jordan",
    "Usain Bolt","Lewis Hamilton"
  ],
  "Marques": [
    "Apple","Samsung","Xiaomi","Sony","Dell","HP","JBL","Lenovo","BMW","Mercedes","Audi",
    "Tesla","Toyota","Honda","Peugeot","Renault","Ford","Ferrari","Lamborghini","Adidas",
    "Nike","Puma","Reebok","Lacoste","Coca-Cola","Pepsi","Nestl√©","Red Bull","Starbucks",
    "Nutella","McDonald‚Äôs","Burger King","KFC"
  ]
};
const CLUSTERS = {
  "Couleurs Formes": [
    ["Rouge","Orange","Bleu","Cyan","Vert","Vert citron","Noir","Gris","Blanc","Ivoire"],
    ["Cercle","Ellipse","Carr√©","Rectangle","Triangle","Pyramide"]
  ],
  "Fruits Fleurs L√©gumes": [
    ["Mangue","Papaye","Ananas","Banane","Pomme","Poire","Raisin","Myrtille","Past√®que","Melon","Citron","Orange","Kiwi","Fraise","Noix de coco","Corossol"],
    ["Concombre","Tomate","Poivron","Oignons","Laitue","Carotte","Aubergine","Courgette","Basilic"],
    ["Hibiscus","Tipanier (frangipanier)","Rose"]
  ],
  "Animaux": [
    ["Chat","Chien","Kangourou","Panda","Koala","Tigre","Lion","Cheval","Z√®bre","Loutre","Castor","Ours"],
    ["Perroquet","Toucan","Aigle","Faucon"],
    ["Dauphin","Requin","Poisson","Tortue"],
    ["H√©risson","Grenouille","Serpent","Souris"]
  ],
  "Transports": [
    ["Voiture","Moto","Bus","Tram","Train","M√©tro","Trottinette","V√©lo"],
    ["Avion","H√©licopt√®re","Mongolfi√®re","Deltaplane"],
    ["Voilier","Jet-sky","Sous-marin","Ferry"]
  ],
  "Sports": [
    ["Football","Rugby","Basket","Handball"],
    ["Tennis","Badminton","Golf","Cricket"],
    ["Boxe","Kung-fu","Danse","Karat√©"],
    ["Formule 1","Rallye","Surf","Voile","Cyclisme","VTT (V√©lo tout-terrain)","Ski","Snowboard"]
  ]
};
const CLUSTER_LABELS = {
  "Fruits Fleurs L√©gumes": ["(fruit)","(l√©gume)","(fleur)"],
  "Couleurs Formes": ["(couleur)","(forme)"]
};
function labelWordByDomain(word, domain){
  const clusters = CLUSTERS?.[domain];
  const labels = CLUSTER_LABELS?.[domain];
  if (!clusters || !labels) return word;
  for (let i = 0; i < clusters.length && i < labels.length; i++){
    if (clusters[i].includes(word)) return `${word} ${labels[i]}`;
  }
  return word;
}
module.exports = { DOMAINS, CLUSTERS, CLUSTER_LABELS, labelWordByDomain };

--- FICHIER : routes/sockets/state/room.js ---
// --- sockets/state/room.js ---
const { genCode } = require('../utils/random');

// code -> room
const rooms = new Map();

/**
 * Cr√©e une salle et initialise tous les √©tats.
 * - players: Map<socketId, { name, hint, vote, isImpostor, score, deviceId? }>
 * - active:  Set<socketId> (joueurs comptabilis√©s pour la manche en cours)
 * - lobbies & timers g√©r√©s par index.js / timer.js
 */
function createRoom(hostId, hostName) {
  let code;
  do { code = genCode(); } while (rooms.has(code));

  const r = {
    hostId,
    state: 'lobby',
    round: 0,
    words: null,

    players: new Map(),      // tous les connect√©s dans la salle
    active:  new Set(),      // sous-ensemble compt√© pour la manche courante

    lastDomain: null,
    lastCommon: null,

    timer: { interval: null, deadline: 0, phase: null },

    lobbyReady: new Set(),
    readyNext:  new Set(),
    used:       {},

    impostor: null,
  };

  r.players.set(hostId, {
    name: hostName,
    hint: null,
    vote: null,
    isImpostor: false,
    score: 0,
  });

  rooms.set(code, r);
  return code;
}

/**
 * Snapshot minimal envoy√© aux clients pour l anecdote de base.
 */
function snapshot(code) {
  const r = rooms.get(code);
  if (!r) return null;

  const players = Array.from(r.players.entries()).map(([id, p]) => ({
    id, 
    name:  p.name,
    score: p.score,
    disconnected: !!p.disconnected,
    spectator: !!p.spectator,
    ready: r.lobbyReady.has(id),
    active: r.active.has(id),
  }));

  return {
    code,
    state: r.state,
    round: r.round,
    players,
  };
}

/**
 * Broadcast un snapshot standard √† toute la salle.
 */
function broadcast(io, code) {
  const s = snapshot(code);
  if (s) io.to(code).emit('roomUpdate', s);
}

module.exports = { rooms, createRoom, snapshot, broadcast };

--- FICHIER : routes/sockets/utils/random.js ---
// --- sockets/utils/random.js ---
const CODE_CHARS = '0123456789';
const CODE_LENGTH = 4;
const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
const genCode = () => Array.from({ length: CODE_LENGTH }, () => CODE_CHARS[Math.floor(Math.random() * CODE_CHARS.length)]).join('');
module.exports = { pick, genCode };

--- FICHIER : utils/hlrank.js ---
// utils/hlrank.js
// routes/utils/hlrank.js
// Paliers HL Rank + p√©nalit√©s

function getHlRank(rp) {
  if (rp >= 200) return 'Ma√Ætre';
  if (rp >= 150) return 'Diamant';
  if (rp >= 120) return 'Or';
  if (rp >= 80)  return 'Argent';
  if (rp >= 40)  return 'Bronze';
  return 'Novice';
}

function getPenaltyByRank(rank) {
  switch(rank) {
    case 'Ma√Ætre':   return 5;
    case 'Diamant':  return 4;
    case 'Or':       return 3;
    case 'Argent':   return 2;
    case 'Bronze':   return 1;
    case 'Novice':   return 0;
    default: return 0;
  }
}

module.exports = { getHlRank, getPenaltyByRank };

/**
 * Calcule les updates de fin de partie pour TOUS les joueurs.
 * - On applique la p√©nalit√© √† tous sauf au vainqueur.
 * - La p√©nalit√© est bas√©e sur le RANG AVANT mise √† jour.
 *
 * @param {Array} players - Liste des joueurs de la partie, format:
 *   {
 *     id: string,          // identifiant stable (deviceId, userId‚Ä¶)
 *     pseudo: string,
 *     rp_total: number,    // total AVANT cette partie (HL Points cumul√©s)
 *     earned: number       // points gagn√©s pendant la partie (ton syst√®me actuel)
 *   }
 * @param {string} winnerId - id du vainqueur (celui qui atteint 10 en premier)
 * @param {Object} [opts]
 *   @param {boolean} [opts.clampMinZero=true] - emp√™che de passer sous 0
 *
 * @returns {Array} updates - une ligne par joueur :
 *   {
 *     id, pseudo,
 *     rp_before, rp_gain, penalty, rp_after,
 *     rank_before, rank_after,
 *     victoires_inc, parties_inc
 *   }
 */
function computeEndgameUpdates(players, winnerId, opts = {}) {
  const { clampMinZero = true } = opts;

  return players.map(p => {
    const rp_before = Number(p.rp_total) || 0;
    const rank_before = getHlRank(rp_before);
    const isWinner = p.id === winnerId;

    const rp_gain = Number(p.earned) || 0;            // points gagn√©s pendant la partie (d√©j√† selon tes r√®gles actuelles)
    const penalty  = isWinner ? 0 : getPenaltyByRank(rank_before);

    let rp_after = rp_before + rp_gain - penalty;
    if (clampMinZero && rp_after < 0) rp_after = 0;

    const rank_after = getHlRank(rp_after);

    return {
      id: p.id,
      pseudo: p.pseudo || '',
      rp_before,
      rp_gain,
      penalty,
      rp_after,
      rank_before,
      rank_after,
      victoires_inc: isWinner ? 1 : 0,
      parties_inc: 1,
      isWinner
    };
  });
}

module.exports = {
  getHlRank,
  getPenaltyByRank,
  computeEndgameUpdates,
};
